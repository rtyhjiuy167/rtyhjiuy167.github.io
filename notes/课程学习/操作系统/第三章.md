## 调度的层次与模型

处理机调度算法的共同目标：资源利用率，公平性，平衡性，策略强制执行。

批处理系统的调度目标：平均周转时间短，系统吞吐量高，处理机利用率高。

分时系统的调度目标：响应时间快、均衡性。

实时系统的调度目标：截止时间的保证、可预测性。

#### 层次

1）高级调度（长程调度、作业调度）

按照某种算法从外存上处于后备队列中的若干个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。

调度的对象是作业。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。

3）中级调度（内存调度）

将暂时不能运行的进程调至外存等待，当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定把它们再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上。

中级调度实际上是存储管理中的对换功能。

可提高内存利用率和系统吞吐量。

3）低级调度（进程调度、短程调度）

按照某种算法从就绪队列里选取进程，并由分派程序将处理机分配给被选中的进程，并设置运行现场，使进程投入执行。

主要功能：保存处理机的现场信息、按某种算法选取进程、把处理机分配给进程。

调度的对象是进程或内核级线程。低级调度是最基本的一种调度，必须配置。

#### 队列模型

按照系统中调度层次的数目，有三种调度对列模型：1.仅有进程调度的。2.具有高级和低级调度的。3.同时具有三种调度的。

仅有进程调度的队列模型：

<img src=".\pictures\仅有进程调度的调度队列模型.png" alt="仅有进程调度的调度队列模型" style="zoom:80%;" />

具有高级和低级调度的队列模型（分时系统）：

<img src=".\pictures\具有低级和高级调度的队列模型.png" alt="具有低级和高级调度的队列模型" style="zoom:80%;" />

同时具有三种调度的队列模型：

<img src=".\pictures\三级调度队列模型.png" alt="三级调度队列模型" style="zoom:80%;" />

## 调度的评价标准

1）CPU利用率

2）周转时间、平均周转时间、带权周转时间、平均带权周转时间

3）系统吞吐量

4）等待时间

5）响应时间

## 调度程序

在操作系统中，用于调度和分派CPU的组件称为调度程序。它通常由排队器、分派器、上下文切换器三部分组成。

1）排队器

2）分派器

3）上下文切换器

不能进行进程调度与切换的情况：1.在处理中断的过程中。2.进程在操作系统**内核**临界区。3.其它需要完全屏蔽中断的原子操作过程中。

切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这个任务称为上下文切换。上下文是指某一时刻CPU寄存器和程序计数器的内容。

注意：用户态和内核之间的切换称为模式切换，而不是上下文切换

## 调度算法

遵循的准则：

* 面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。
* 面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用。

一、先来先服务（first-come first-served，FCFS）

不利于短进程

二、短进程优先（short process first，SPF）、短作业优先（short job first，SJF）

平均等待时间最少，效率最高。适合批处理系统

三、时间片轮转（RR）

适用于分时系统

四、优先级调度算法（priority-scheduling algorithm，PSA）

在采用优先级进程调度时，运行的进程不一定是优先级最高的，因为优先级最高的进程可能处于等待状态。

优先级设置原则：1）系统进程>用户进程；2）交互型进程>非交互型进程；3）I/O型进程>计算型进程

1.非抢占式优先级调度算法

2.抢占式优先级调度算法

抢占原则：1）优先权原则；2）短进程优先原则；3）时间片原则

五、高响应比优先调度算法（highest response ratio next，HRRN）
$$
\begin{aligned}
优先权（响应比）=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}
\end{aligned}
$$
六、最早截止时间优先（earliest deadline first）

适用于实时系统

七、最低松弛度优先（least laxity first）
$$
\begin{aligned}
松弛度=必须完成的时间点-当前时间点-其本身的运行时间
\end{aligned}
$$
适用于实时系统

八、多级反馈队列调度算法

终端型用户：由于终端型用户提交的作业多属于交互型作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。
短批处理作业用户：对于这类作业，如果可在第一队列中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。
长批处理作业用户：对于长作业，它将依次在第1，⋯，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。

#### 优先级倒置

低优先级进程正在访问的临界区时，高优先级进程插入，但也需访问临界区，所以无法继续运行，而优先级在前两者之间的进程插入，延缓低优先级进程退出临界区的时间。

解决方法：

* 简单的方法：访问临界区时不允抢占处理机。

* 适用的方法：建立在动态优先级继承基础上。当优先级更高的进程访问已被低优先级进程正在访问的临界区时，低优先级的进程继承高优先级进程的优先级。

## 死锁

死锁产生原因：系统资源竞争、进程推进顺序不当。

产生死锁的必要条件：1.互斥条件。2.请求和保持条件。3.不可抢占条件。4.循环等待条件。

#### 死锁处理策略

1）死锁预防

破坏死锁产生的4个必要条件之一。

* 破坏请求和保持条件：采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源。
* 破坏循环等待条件：采用顺序资源分配法。

2）死锁避免

在资源动态分配过程中，防止系统进入不安全状态。

* 系统安全状态

  并非所有不安全状态都是死锁状态

* 银行家算法

  不会限制申请资源的顺序

  数据结构描述：

  1.可利用资源向量 Available：含有m个元素的数组，其中每个元素代表一类可用的资源数目。

  2.最大需求矩阵Max ：n x m矩阵，定义系统中n个进程中每个进程对m类资源的最大需求。一行代表一个进程，一列代表一类资源。

  3.分配矩阵Allocation : n x m矩阵，定义系统中每类资源当前已分配给每个进程的资源数。

  4.需求矩阵 Need: n x m矩阵，表示每个进程还需要的资源。

  5.工作向量 Work : 是通过执行安全性算法得出的结果。

  T<sub>0</sub>时刻的资源分配表：
  
  <img src=".\pictures\T0时刻的资源分配表.png" alt="T0时刻的资源分配表" style="zoom:50%;" />

T<sub>0</sub>时刻的安全序列：

<img src=".\pictures\T0时刻的安全序列.png" alt="T0时刻的安全序列" style="zoom:70%;" />

注意：如果没有进程提出需求，即使不满足Max的安全序列，也应认为此刻系统没有进入死锁状态。

3）死锁检测

* 资源分配图

  从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源；从资源到进程的边称为分配边，表示该类资源已有一个资源分配给了该进程。

* 死锁定理

  资源分配图不能化简，即死锁

4）死锁解除

* 资源剥夺法
* 撤销进程法
* 进程回退法