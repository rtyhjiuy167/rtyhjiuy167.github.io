### 标识符

在实体中，能够唯一标识不同实体实例的属性或属性集被称为标识符。
如果实体中找不到任何单个属性可以做标识符，可选取多个属性的组合作为标识符。

<img src="https://img-blog.csdnimg.cn/cfcc4f2223a54d129bb3b0d6191540c2.png" style="zoom:80%;" />

在图形表示上，作为标识符的属性需加上下画线。如果是复合标识符，则构成该复合标识符的所有属性都需加上下画线。

图中，`<pi>`表示主标识符等价于主键，标识符与主键的区别是标识符是一个逻辑概念，主键是物理概念。`<M>`表示不能为空，等价于NOT NULL。

### 弱实体

在现实世界中，某些实体对另一些实体有逻辑上的依赖联系，即一个实体的存在必须以另一个实体的存在为前提，前者被称为弱实体，而被依赖的实体被称为强实体。

弱实体分为标识符依赖弱实体与非标识符依赖弱实体。

1. 标识符依赖弱实体

   标识符依赖弱实体的标识符取决于其所依赖的所有实体的标识符。对标识符依赖弱实体的联系连线符号，在弱实体一侧有一个三角形的符号。下图表示，一个成绩必须有一个学生，一个学生可以有0个或多个成绩。

<img src="https://img-blog.csdnimg.cn/cf0c0d0a79fc43e68ab0147e211b12c7.png" style="zoom:80%;" />

2. 非标识符依赖弱实体

   标识符依赖弱实体有自己的标识符。下图表示，一个商品订单必须对应一个商品，一个商品可以有0个或多个商品订单。

<img src="https://img-blog.csdnimg.cn/b8a603690caf421581dc1e7e23f929c3.png" style="zoom:80%;" />

### 概念模型转化为逻辑模型

在`check Model`无误后，即可转换。`Tools`⟶`Generate Logical Data Model`⟶`General`⟶`Generate new Logical Data Model`⟶自定义名称⟶`Configure Model Options `⟶`Model Setting`⟶`Notaion`⟶选择`Entity/Relationship`。

### 逻辑模型转化为物理模型

在`check Model`无误后，即可转换。`Tools`⟶`Generate Physical Data Model`⟶`General`⟶`Generate new Physical Data Model`⟶DMBS处选择自己使用的数据库开发工具并自定义名称⟶`Configure Model Options `⟶`Model Setting`⟶`Notaion`⟶选择`Relational`。

如果DMBS处为空，请将PowerDesigner的安装目录下的`Resource Files\DBMS`目录添加即可。

### 物理模型生成SQL语句

选中物理模型窗口后，`Model`⟶`Model Properties`⟶`Preview`

## 函数依赖理论

1. 函数依赖的定义

   设有一关系模式R(U)，X和Y为其属性U的子集，即X⊆U，Y⊆U。设t、s是关系R中的任意两个元组，如果t[X]=s[X]，必有t[Y]=s[Y]，那么称Y函数依赖于X，或称X作为决定因子决定Y函数，即称X⟶Y在关系模式R(U)上成立。

   1）完全函数依赖

   Y函数依赖于X，但Y函数不依赖于X的任何真子集。
   例如：对于关系表中的某个属性，必选根据主键或复合键才能得到该属性的具体取值。

   2）部分函数依赖

   例如：对于关系表中的某个属性，可根据组成复合键的其中一个属性得到该属性的具体取值。

2. 传递函数依赖

   设X、Y、Z是某关系的不同属性集，如果X依赖于Y，Y不依赖于X，Y依赖于Z，则称Z对X存在函数传递依赖。

   通俗来讲即对于关系表中的两个属性A、B，由主键的取值可得到A，由A的取值又可以得到B的取值。

3. 多值依赖

   设U是关系模式R的属性集，X和Y是U的子集，Z=U-X-Y，x、y、z表示属性集X、Y、Z的值。对R的关系r，在r中存在元组(x，y<sub>1</sub>，z<sub>1</sub>)和(x，y<sub>2</sub>，z<sub>2</sub>)时，也存在(x，y<sub>1</sub>，z<sub>2</sub>)和(x，y<sub>2</sub>，z<sub>1</sub>)，那么称多值依赖，即X⟶⟶Y在模式R上成立。

通俗来讲，模式可理解为一张关系表(但没有数据)。属性集，可以理解一张关系二维表的一个或多个属性的集合（应该不为空）。关系模式R(U)可理解为存在属性集U的关系二维表。关系中的元组，即关系二维表中的一行。对模式的关系r，可理解为已经构建出了一张有数据的二维关系表。属性集的取值，表示属性的具体取值。多值依赖其实是说，每个二维表中对应唯一的主键，不同的属性分别都有一组的取值。

## 关系规范化范式

1. 第1范式（1NF）

   第1范式指关系表的属性列不能重复，并且每个属性列都是不可分割的基本数据项。在关系数据库中，第一范式是对关系表的基本要求，不满足第一范式的二维表不是关系。

   例如：学生(<u>学号</u>，姓名，<u>课程号</u>，成绩，系名，住址，联系方式) 中“联系方式”属性可以再细分“电话”、“电子邮件”等。所以其不满足1范式。

   注意：仅第1范式允许部分函数依赖与相互依赖(存在相互也就意味着存在属性部分依赖)。

2.  第2范式（2NF）

   如果关系满足第1范式，并消除了关系中的属性部分函数依赖，则该关系满足第2范式。

   例如：学生(<u>学号</u>，姓名，<u>课程号</u>，成绩，系名，住址，电话)关系中，"学号"→"姓名"、"学号"→"电话"(不需要"完整"的复合键就可得到其他属性的取值)可知其不满足第2范式。

3. 第3范式（3NF）

   如果关系满足第2范式，并切断了关系中的属性传递函数依赖，则该关系满足第3范式。

   例如：学生(<u>学号</u>，姓名，系名，住址，电话)关系中，"学号" →"系名"，"系名"→"住址"，可知其不满足第3范式。

4. 巴斯—科德范式（BCNF范式）

   如果满足3NF范式并且关系上所有函数依赖的决定因子都是候选键，则该关系满足BCNF范式。

   例如：书名(<u>书号</u>，书名，作者)关系中 "书名"与"作者" → "书号"，而 "书名"与"作者" 不是候选键，其满足第3范式但不满足BCNF范式。

5. 第4范式（4NF）

   如果关系满足BCNF范式，并消除了多值函数依赖，则该关系满足第4范式。

6. 第5范式（5NF）

   如果一个关系为消除其中连接依赖，进行投影分解，所分解的各个关系均包含原关系的一个候选键，则这些分解后的关系满足第4范式。