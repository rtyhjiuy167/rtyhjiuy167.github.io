#### 限制条件

```tsx
// extends 限制 Type 必须要有 length 属性，且其值必须为 number 类型
// Type 会根据我们传入的参数自动推导类型
function longest<Type extends { length: number }>(a: Type, b: Type) {
    if (a.length >= b.length) {
        return a
    } else {
        return b
    }
}
```

#### 指定参数类型

```tsx
function fn<Type>(arr1: Type[], arr2: Type[]): Type[] {
    return arr1.concat(arr2)
}

// const arr = fn(["string"], [1, 2, 3, 4])
// 上句代码不允许执行，因为传入["string"]时，Type已自动推断为 string 了
// 可以指定类型参数解决，不过除非业务需要，否则不推荐
const arr = fn<string | number>(["string"], [1, 2, 3, 4])
```

#### 函数重载

即同个函数可以传如不同的参数。

在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数，即少用函数重载。

```tsx
// 前两个为重载签名
// 后一个为实现签名
function makeDate(timestamp: number): Date
function makeDate(m: number, d: number, y: number): Date
function makeDate(mOrTimestamp: number, d?: number, y?: number) {
    if (d !== undefined && y !== undefined) {
        return new Date(y, mOrTimestamp, d)
    } else {
        return new Date(mOrTimestamp)
    }
}
```

#### 形参展开

可以接收多个参数，收集成一个数组。

```tsx
function mutiply(n: number, ...m: number[]) {
    return m.map(x => x * n)
}

const a = mutiply(10, 1, 2, 3, 4, 5)
console.log(a)// [ 10, 20, 30, 40, 50 ]
```

#### 实参展开

```tsx
const angle1 = Math.atan2(2, 3)
const args = [8, 5] as const
const angle2 = Math.atan2(...args)
```

#### 参数结构

```tsx
function sum({ a, b, c }: { a: number, b: number, c: number }) {
    console.log(a + b + c)
}
sum({ a: 10, b: 3, c: 9 })
```

#### 属性签名

可以定义对象中的键的类型及值的类型

```tsx
type Arrayish = {
    [n: number]: number
}
// 数组本身也是对象，键为 nubmer
const arr1: Arrayish = [1, 2, 3] 
```

#### 只读属性

```tsx
//声明一个对象类型 其有一个只读的属性 prop
interface SomeType {
    readonly prop: string
}

// 可以进行初步赋值，但之后不能修改
let someType: SomeType = {
    prop: "123"
}


interface Home {
    readonly person: {
        name: string // 可修改
        readonly age: number // 不可修改
    }
}

// 如果只读属性被赋予可写的对象，则只读失效
```

#### 泛型类型

给变量设置泛型的类型

```tsx
function identity<Type>(arg: Type): Type {
    return arg
}
// 普通的定义类型
let myIdentity1: <Type>(arg: Type) => Type = identity;
// 更改 Type 名称，此处的 Input 无任何含义，只是标识而已
let myIdentity2: <Input>(arg: Input) => Input = identity;
// 以对象字面量形式
let myIdentity3: { <Type>(arg: Type): Type } = identity;
```

#### keyof

```tsx
type Point = {
    x: number
    y: Number
}
type P = keyof Point // 即 p 的类型必须是 Point 的某一属性，即键名
const p1: P = 'x'
const p2: P = 'y'
// const p3: P = 'z' // 错误,Point 中没有 'z' 键
```

```tsx
type Arrayish = {
    [n: number]: number
}
type A = keyof Arrayish // A 即 number
const a: A = 1

type Mapish = {
    [haha: string]: number
}
type M = keyof Mapish // M 为 number | string ， 因为对象的键可以写成 数值，例如 123:321
const m1: M = 123
const m2: M = '123'
```

#### 在泛型中使用类型参数

```tsx
// 限制传入的参数 key ，其必须是 obj 的其中一个属性
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
    return obj[key]
}
let x = {
    a: 1,
    b: 2,
    c: 3
}
// 'a' 是 x 对象的其中一个属性，合法
getProperty(x, 'a')

// 'd' 不是 x 对象的其中一个属性，不合法
// getProperty(x,'d')

```

#### 索引访问类型

```tsx
//定义一个对象类型
type Person = {
    name: string,
    age: number,
    alive: boolean
}
// 通过索引访问获得其类型
type Age = Person['age'] // Age 即 number

type T1 = Person['age' | 'name'] // T1 类型为 'age' 或 'name' 对应的值的类型，即联合类型 string | number

type T2 = Person[keyof Person] // keyof Person 表示对象 Person 中的键，则T2 是 string | number | boolean 的联合类型

const MyArray = [
    { name: 'Alice', age: 13 },
    { name: "Jack", age: 16 }
]

// P 为 { name: string , age: number }
type P = typeof MyArray[number]

// Name 为 string
type Name = typeof MyArray[number]['name']
```

