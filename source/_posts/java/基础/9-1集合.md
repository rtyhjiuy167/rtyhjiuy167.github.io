我们保存多个数据使用的是数组，但数组有许多不足之处：

* 数组初始化之后，长度就确定了，不便于扩展
* 数组中提供的属性和方法少，补便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数
* 数组存储的数据是有序的、可以重复的

Java集合可分为Collection和Map两种体系。

## Collection

Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的。

Collction 接口定义了存取一组对象的方法，子接口实现的子类为单列集合。

<img src="C:\Users\Administrator\Desktop\_posts\java\基础\pictures\集合.png" alt="集合" style="zoom:80%;" />

### Collection抽象方法

* add(Object e)

  ```java
  Collection list = new ArrayList();
  list.add(10); // 自动装箱 转成 Integer
  ```

* addAll(Collection c)

* contains(Object o)

  查找元素是否存在。底层使用对象的`equals`方法进行内容的判断，自定义对象需要重写`equals`方法。

* containsAll(Collection c)

  查找集合中的元素是否全部都存在

* equals(Object o)

  调用`equals`方法进行内容判断，如果集合有序，则按顺序判断。

* hashCode()

  返回哈希值

* iterator()

  返回集合的迭代器对象。

* isEmpty()

  判断集合是否为空

* remove(Object o)

  移除某个元素。底层使用对象的`equals`方法进行内容的判断，自定义对象需要重写`equals`方法。

* removeAll(Collection c)

  删除所有指定的元素

* retainAll(Collection c)

  修改当前的集合为两个集合的交集。

* size()

  获取元素的个数

* toArray()

  将集合转换成数组

### List接口

鉴于Java中数组存储数据的局限性，我们通常使用 List 替代数组，作为"动态数组"。

List 集合中元素有序、且可重复，集合中每个元素都有其对应的顺序索引。

List接口的实现类常用的有：ArrayList、LinkedList 和 Vector。

#### List 的接口方法

* add(int index, E element)

  向指定索引处添加元素

*  addAll(int index, Collection c)

* get(int index)

* indexOf(Object o)

* lastIndexOf(Object o)

* remove(int index)

  删除指定索引的元素

* set(int index, E element)

  替换

* subList(int fromIndex, int toIndex)

  返回子集合

#### ArrayList

ArrayList  是线程不安全的，但效率较高，没有 synchronized。

ArrayList 中维护了一个 数组： transient Object[] elementData，ransient 该属性在序列化时，会被忽略。

创建Arraylist 对象时，如果使用无参构造器，则初始elementData 容量为0。

第一次添加，则扩容elementData为10 ，如需要再次扩容，则扩容1.5倍。

如果使用的是指定大小的构造器，则初始elementData容量为指定大小，
之后若需扩容，则扩容1.5倍。

#### LinkedList

LinkedList 底层实现了双向链表和双端队列特点，线程不安全，没有实现同步。

LinkedList 中维护了两个属性 first 和 last ，其分别指向首节点和尾节点。

每个节点（Node对象），里面又维护了 prev、item、next三个属性。



#### Vector

Vector 是线程同步的，即线程安全，效率较低
无参构造，初始为0，添加元素后为10，之后按两倍扩

### Set 接口



## Map

Map 接口有直接的实现子类。

Map  接口定义了存取具有映射关系"key-value"的方法，实现的子类为双列集合

## Iterator 接口

Iterator 方法：

* hasNext()

  判断是否还有下个元素

* next()

  游标下移，并返回下移后的所指向的元素。如果游标已指向的最后一个元素，若再移动则会抛出 NoSuchElementException 的异常。

```java
// 1.先得到 col 集合对应的迭代器
Iterator iterator = col.iterator();
//2.循环遍历
while (iterator.hasNext()) {
    Object next = iterator.next();
    System.out.println(next);
}

// iterator = col.iterator() 指针已指向最后，若要再次遍历，应重置
iterator = col.iterator();
while (iterator.hasNext()) {
    Object next = iterator.next();
    System.out.println(next);
}
        
// 使用增强for遍历 推荐！
for (Object o : col) {
    //这个的底层仍是使用迭代器
    System.out.println(o);
}
```

