

## 存储器结构

对于通用计算机而言，存储器至少应具有三级：CPU寄存器、主存、辅存。在较高档的计算机中，可细分为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质。CPU寄存器、高速缓存、主存储器与磁盘缓存属于操作系统存储管理的管辖范畴，掉电后它们中存储的信息不再存在。

<img src=".\pictures\计算机系统存储层次示意图.png" alt="计算机系统存储层次示意图" style="zoom:100%;" />

主存储器简称主存或内存。寄存器具有与处理机相同的速度，故对寄存器的访问速度最快。

对主存器的访问是以字节或字为单位的。

## 程序的链接和装入

用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可执行的程序。

编译：由编译程序（Compiler）将用户源代码编译成若干目标模块。

链接：由链接程序（Linker）将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块（Load Moudle）。

装入：由装入程序（Loader）将装入模块装入内存运行。

<img src=".\pictures\对用户程序的处理步骤.png" alt="对用户程序的处理步骤" style="zoom:80%;" />

#### 程序的装入

将一个装入模块装入内存时，可有如下三种装入方式：

1）绝对装入方式（Absolute Loading Mode）

只适用于单道程序环境，此时还没有产生操作系统。

2）可重定位装入方式（Relocation Loading Mode）

可重定位装入方式又称静态重定位。地址变换在进程装入时一次完成，以后不可改变。

对于用户程序所编译的若干装入模块，它们的起始地址通常都是从0开始的。装入到内存后，通过内存块的起始地址与模块相对地址进行相加转变为物理地址。

在装入时对目标程序（即用户程序）中指令和数据地址的修改过程（装入模块中的逻辑地址需要加上所处内存块的起始地址）称为重定位。

3）动态运行时的装入方式（Dynamic Run-time Loading）

动态运行时的装入方式并不立即把装入模块中的逻辑转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行。

整个系统应设置一个重定位寄存器。

优点：可以将程序分配到不连续的存储区；可根据需要动态申请分配内存；便于程序段的共享；可以使用紧凑（又称拼接）来解决碎片问题。

#### 程序的链接

1）静态链接

2）装入时动态链接

便于修改和更新、便于实现对目标模块的共享

3）运行时动态链接

凡是在执行过程中未被用过的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅能加快程序的装入过程，而且可节省大量的内存空间。

## 内存保护

多进程的执行通过内存保护实现互不干扰。

内存保护需要由操作系统和硬件机构合作完成。内存保护可采用两种方法：

1）在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。

2）采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）来实现。重定位寄存器含最小的物理地址，界地址寄存器含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器地值后映射称物理地址。

加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载。

## 内存共享

进程的内存中只有只读的区域才可以共享。可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。

在通信的进程之间也存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。

共享的段在各进程的段表中的段号不一定相同。

### 传统存储器管理方式

#### 连续分配

1）单一连续分配

仅一道用户程序占用整个用户区。

2）固定分区分配

分区大小事先划分。作业一旦装入某分区，则整个分区的大小被其占用。

存在内部碎片，无外部碎片。

3）动态分区分配

分区的大小会随着作业的装入而变小，作业的结束而变大，

存在外部碎片，无内部碎片。

顺序搜索的动态分区分配算法：

* 首次适应（First Fit）算法

  空闲分区以**地址递增**的次序链接。从链首开始顺序查找，找到能满足要求的第一个空闲分区分配给作业。

  通常是最好和最快的。不过每次分配查找都要从内存的地址开始，会增加开销。

* 邻近适应（Next Fit）算法

  分配内存时从上次查找结束的位置开始查找。常常导致在内存空间的尾部分裂称小碎片。通常比首次适应算法要差。

* 最佳适应（Best Fit）算法

  空闲分区按**容量递增**的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业。

  性能通常很差。会产生**最多**的外部碎片。

* 最坏适应（Worst Fit）算法

  空闲分区按**容量递减**的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业。性能通常很差。

基于索引搜索的动态分区分配算法：

* 快速适应（quick fit）算法
* 伙伴系统（buddy system）
* 哈希算法

#### 非连续分配(离散分配)

进程中的块称为页或页面（Page），内存中的块称为页框或页帧（Page Frame）。

1）基本分页存储管理

分页管理方式从计算机的角度考虑设计，目的是提高内存利用率，提升计算机的性能，分页通过硬件机制实现，对用户完全透明。

分页存储管理系统中通常设置一个页表寄存器（PTR），用于存放页表在内存的起始地址F和页表长度M。

平时，进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当进程被调度执行时，才将页表始址和页表长度装入页表寄存器中。

分页存储管理系统中通常会增设一个具有并行查找能力的高速缓冲存储器——快表（TLB），又称联想存储器（Associative Memory）。

具有快表的地址变换机构：

<img src=".\pictures\具有快表的地址变换机构.png" alt="具有快表的地址变换机构" style="zoom:80%;" />

上图中，页表中的每个页表项记录物理块号，每个页表项是有一定长度的。页号所对应的页表项地址=页号x页表项长度+页表始址。

注意：有些题会忽略查快表的时间。

建立多级页表的目的在于建立索引，以便不用浪费主存空间区存储无用的页表项，也不用盲目地顺序式查找页表项。

在多级页表中，页表基址寄存器存放的是顶级页表的起始物理地址。

顶级页表最多只能有1个页面。

分页管理的地址空间是一维的。

2）基本分段存储管理

<img src=".\pictures\分段系统的地址变换过程.png" alt="分段系统的地址变换过程" style="zoom:80%;" />

分段管理方式考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

注意：动态链接要求以段作为管理单位

与分页管理类似，分段管理的保护方法主要有两种：1.存取控制保护。2.地址越界保护。注意：分页管理只需要判断页号是否越界，页内偏移是不需要判断。而段式管理既需要判断段号，还需要判断段内偏移。因为页的大小是统一的，段的大小是不统一的。

分段管理的地址空间是二维的。

3）基本段页式存储管理

一张段表与多张页表

在具有快表的段页式存储管理方式中，地址变换过程：
在CPU给出有效地址后，由地址变换机构自动将页号送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号比较，若找到匹配页号，表示要访问的页表项在快表中。可直接从快表读出该页对应物理块号，送到物理地址寄存器中。
如果快表中没有对应页表项，则再访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页表项存入快表。但若寄存器已满，则0S必须找到合适的页表项换出。



一次性：作业必须一次性地全部装入内存后方能开始运行。这会造成两个问题：1）大作业无法在小内存中运行2）当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行。

驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。问题：事实上，在一个时间段内，只需要访问作业地一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

## 覆盖与交换

覆盖技术已成为历史

交换又称对换，为实现对换，系统应具备三方面功能：对换空间管理，进程换出，进程换入。

在以进程为单位进行对换时，并非每次将整个进程换出。a.从结构上讲，进程是由程序段、数据段和进程控制块组成的，其中进程控制块总有部分或全部常驻内存，不被换出。b.程序段和数据段可能正被若干进程共享，此时它们也不能被换出。

### 虚拟内存的实现

> 请求分页存储管理
>
> 请求分段存储管理
>
> 请求段页式存储管理

与传统存储器管理方式的主要区别：

* 操作系统要提供请求调页(段)功能。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
* 操作系统要提供页面(段)置换功能。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

虚拟内存的三个主要特征：
多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际容量。

虚拟内存空间的大小实际为内存容量和外存容量之和，最大容量为计算机的地址位数能容纳的最大容量。

#### 请求分页存储管理

1. 请求页表机制

| 页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址 |
| :--: | :------: | :-----: | :-------: | :-----: | :------: |

状态位P：应用程序是否已调入内存。
访问字段A：记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，提供给置换算法在选择换出页面时参考。
修改位M：用于标识该页在调入内存后是否被修改过。
外存地址：用于指出该页在外存上的地址，通常时物理块号，供调入该页时参考。

2. 缺页中断机制（属于内中断中的故障）

   在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

与一般中断的区别：1）在指令执行期间产生和处理中断信号。2）一条指令在执行期间可能产生多次缺页中断。

3. 地址置换机构

   新增步骤：1）请求调用。2）页面置换。3）修改请求页表中新增的表项。

具有块表机构的请求分页系统中，访问一个逻辑地址时，若发现缺页，则地址变换步骤：查块表（未命中）⟶ 查慢表（发现未调入内存）⟶ 调页（调入的页面对应的表项会直接加入块表）⟶ 形成物理地址

#### 请求分段

1. 请求段表机制

| 段名 | 段长 | 段基址 | 存取方式 | 访问字段A | 修改位M | 存在位P | 增补位 | 外存始址 |
| :--: | :--: | :----: | :------: | :-------: | :-----: | :-----: | :----: | :------: |

存取方式：由于应用程序中的段是信息的逻辑单位，可根据存取方式字段对它实施保护。
增补位：这是请求分段式管理中所持有的字段，用于表示本段在运行过程中是否做过动态增长。
外存始址：指示本段在外存中的起始地址，即起始盘块号。

### 页面置换算法

页面的换入、换出需要磁盘I/O操作，会有较大的开销，因此页面置换算法应该追求最少的缺页率。

* 最佳置换算法(OPT，Optimal)

  每次选择的被淘汰页面将是以后永不使用的，或在最长时间内不再被访问的页面。

  该算法无法实现。

* 先进先出置换算法(FIFO)

  每次淘汰最新进入内存的页面，即选择内存中驻留时间最久的页面予以淘汰。

  FIFO算法会产生所分配的物理块数增大而页故障数不减反增的异常现象，称为 Belady 异常。

  实现简单，但性能较差。

* 最近最久未使用置换算法（LRU，Least Recently Used）

  每次选择的被淘汰页面是最近最久未使用的页面。

  LRU算法的实现需要专门的硬件支持，性能好，但实现困难，开销大。

* 时钟置换算法（CLOCK）

  CLOCK算法又称最近未用算法（NRU）

  CLOCK算法将内存中的所有页面都通过链接指针链接成一个循环队列。当页面被访问时，其访问位被置1，置换算法在选择一页淘汰时，只需检测页的访问位，如果为0，就选择该页换出；若位1，则重新将它置0，继续检查下一个页面。

  每次选择的被淘汰页面最多会进行两次扫描

* 改进型的时钟置换算法

  简单的CLOCK算法仅考虑到一个页面是否被访问过，而改进型的时钟置换算法还考虑了页面是否被修改过。

  每次选择的被淘汰页面最多会进行四次扫描。被淘汰页面的优先级：最近没访问且没修改 ⟶ 最近没访问但修改过 ⟶ 最近访问过但没修改 ⟶ 最近访问过且修改过
  
  对于驻留集为m个页框（初始所有页帧均为空），在长为p的引用串(一段时间内需要访问的页号序列，又称访问串)中具有n个不同的页号（n>m），所有算法的页故障数的上限都是p，下限都是n

## 页框分配

分配页框是针对页面的，每次缺页必定发生分配页框。

驻留集：指请求分页存储管理中给进程分配的物理块的集合。
若驻留集太小，会导致缺页频繁，系统要花费大量的实践来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致躲到程序并发度下降，资源利用率降低。
在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

工作集：指在某段时间间隔里，进程实际访问页面的集合。工作集大小≤驻留集大小。

#### 内存分配策略

固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。

可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。

局部置换：发生缺页时只能选进程自己的物理块进行置换。

全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。驻留集大小可能发生变化。

1）固定分配局部置换（Fixed Allocation，Local Replacement）
采用固定分配策略时，可采用平均分配算法、按比例分配算法或考虑优先权地分配算法。

2）可变分配全局置换（Variable Allocation，Global Replacement）
只要发生缺页就分配一个新的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块队列中取出一块分配给该进程；若已无空闲物理块，则可选择内存中的一个未锁定的页面换出到外存，再将该物理块分配给缺页的进程。

3）可变分配局部置换（Variable Allocation，Local Replacement）
当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地发生缺页中断，系统会为进程多分配几个物理块，直至该进程缺页率趋于适当程度。如果进程在运行中缺页率特别低，则可适当减少分配给该进程地物理块。

#### 页面调入策略

何时调入页面

* 预调入策略

  目前预测页的成功率仅约50%

* 请求调入策略

从何处调入页面

* 系统拥有足够的对换区空间时

  页面的调入、调出都是在内存与对换区之间进行。在进程运行前，需将进程相关的数据从文件区复制到对换区。

* 系统缺少足够的对换区空间时

  所有的数据都直接从文件区调入。换出时，对于可能被修改的部分，调到对换区，而不会被修改的数据不必再将它们重写到磁盘，以后调入时，仍从文件区直接调入。

* UNIX方式

  凡是未运行过的页面，都从文件区调入。内存空间不足，需要换出时，则将页面调到对换区中。


​		文件区管理的主要目标是提高文件存储空间的利用率，然后才提高对文件的访问速度，因此，对文件区空间的管理采取离散分配方式。
​		对换空间管理的主要目标是提高进程换入和换出的速度，然后才是提高文件存储空间的利用率，因此，对对换区空间的管理采取连续分配方式，较少的考虑外存中的碎片问题。

当CPU的利用率为10%，磁盘交换区的利用率为99%，其它I/O设备的利用率为5%时，说明：系统出现抖动现象，此时任务作业不多，程序度数过高，物理内存严重短缺，交换操作频繁，应减少程序度数和提高内存容量来提供CPU利用率。