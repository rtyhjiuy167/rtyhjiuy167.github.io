

# 第一章 数据结构及算法的相关概念和术语

### 数据元素

数据元素是组成数据的基本单位，是数据集合的个体。

一个数据元素可有一个会多个数据项组成，数据项是有独立含义的最小单位，此时的数据元素通常称为记录。

### 数据类型

数据类型是一组性质相同的值集合以及定义在这个值集合上的一组操作的总称。

* 原子类型

* 结构类型

* 抽象数据类型（ADT）

  抽象数据类型定义了一个数据对象、数据对象中个元素键的结构关系以及处理数据的操作。可以用ADT定义一个完整的数据结构。

  从某种意义上讲，抽象数据类型和数据类型是指上市一个概念，只不过 ADT 更广泛。

  抽象数据类型的定义取决于客观存在的一组逻辑特性，而与其在计算机内如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不会影响其外部使用。

  例如 表、堆栈、队列、串、树、图等结构就是一个个不同的抽象数据类型。不过需要注意，这些结构为逻辑结构，例如栈可采用线性存储或链式存储。

   抽象数据类型最重要的特点是**数据抽象**和**信息隐蔽**。

### 数据结构三要素

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

数据结构涉及到的三种最基本逻辑结构为：线性结构、树状结构、图状结构，两种基本存储结构为：顺序存储结构、链式存储结构。

##### 逻辑结构

逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。数据的逻辑结构独立于其存储结构。

数据的逻辑结构分为线性结构和非线性结构，例如：线性表、有序表、集合、树、图等。

##### 存储结构

存储结构（又称物理结构）是逻辑结构在计算中的存储映像。例如：循环队列、顺序表、哈希表、链表等。

数据的存储结构：

* 顺序存储

  优点：可以实现随机存取，每个元素占用最少的存储空间

  缺点：只能使用相邻的一整块存储单元，可能产生较多的外部碎片

* 链式存储

  优点：不会产生碎片，能充分利用所有存储单元

  缺点：每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取

* 索引存储

  优点：检索速度快

  缺点：附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，会花费较多时间

* 散列存储

  优点：检索、增加和删除结点的操作都很快

  缺点：若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加事件和空间的开销

#####  数据的运算

运算的定义是针对逻辑结构的，指出运算的功能。运算的实现是针对存储结构的，指出运算的具体操作步骤。

可以说一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。

### 算法

算法是对特定问题求解步骤的一种描述。

算法特性：有限性、确定性、可行性、输入、输出。

常用的事件复杂频率计数：O(1) 常数型、O(log<sub>2</sub>n) 对数型、 O(n) 线性型、O(nlog<sub>2</sub>n) 二维型、O(n<sup>2</sup>) 平方型、O(n<sup>3</sup>) 立方型、 O(n!) 指数型、 O(2<sup>n</sup>) 指数型。

一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。

算法原地工作是指算法所需的辅助空间是常量。

# 第二章 线性表

### 线性表的定义

线性表是具有**相同数据类型**的n（n ≥ 0）个数据元素的**有限序列**，其中n为表长当 n = 0 时线性表是一个空表。

若用 L 命名线性表，则其一般表示为 L = （a<sub>1</sub>，a<sub>2</sub>，⋯，a<sub>n</sub>） ，式中，a<sub>1</sub>为表头元素，a<sub>n</sub>为表尾元素。

线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中再逻辑结构上相邻的数据元素存储在连续的物理存储单元中。

线性表是一种**逻辑结构**，表示元素之间一对一的相邻关系。

通常用高级语程序设计语言中的**数组**来描述线性表的**顺序存储结构**：

```c
#define MAXSIZE 100 /*此处的宏定义常量表示线性表的最大长度*/
typedef struct {
	ElemType data[MAXSIZE]; /*线性表占用的数组空间*/
	int last; /*记录线性表中最后一个元素在数组elem[ ]中的位置(即下标值),空则为-1。该字段也可以改为记录数组的长度。length 与 last 之间分关系为 last+1 = length */
}SeqList; /*顺序表的类型定义*/
```

上述的一维数组是静态分配的，动态分配的如下：

```c
typedef struct {
	ElemType *data; /*线性表占用的数组空间*/
	int MaxSize,length;  /*数组的最大容量和当前个数*/
}SeqList;/*动态分配数组顺序表的类型定义*/
```

注意：动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取，只是分配的空间大小可以在运行时动态决定。

地址计算 Loc(a<sub>i</sub>)=Loc(a<sub>1</sub>)+(i-1)*k，其中Loc(a<sub>1</sub>)称为基地址。

#### 线性表的初始化

仅针对静态分配的初始化：

```c
void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}
```

#### 线性表的插入

```c
// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引
// ElemType e 表示插入的元素
bool ListInsert(SeqList &L,int i,ElemType e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false; 

	for (int j = L.length-1; j >= i; j--)  L.data[j+1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}
```

问题规模 n 为待插入元素的数组长度。

时间复杂度分析：
最好的情况是新元素插入到表尾，不需要移动数组中原本的元素，时间复杂度为O(1)。
最坏的情况是新元素插入到表头，需要移动数组中原本的n个元素，时间复杂度为O(n)。
平局情况下，假设新元素插入到任何位置的概率p都相同，i=0,1,⋯n，共n+1个位置，则p=1/(n+1)。即当i=0，循环n次；i=1，循环n-1次，⋯，i=n-1，循环1次；i=n，循环0次，所以平均循环次数=np+(n-1)p+(n-2)p+⋯+p=(1+2+⋯+n)/(n+1)=n/2，故时间复杂度为O(n)。

#### 线性表的删除

```c
// SeqList &L 表示待删除元素的数组
// int i 表示待删除元素在数组中的索引
// ElemType e 返回删除的元素
bool ListDel(SeqList& L, int i, ElemType& e) {
	if (i<0 || i> L.length - 1) return false;
	e = L.data[i];
	for (int j = i; j <= L.length - 1; j++)  L.data[j] = L.data[j + 1];
	L.length--;
	return true;
}
```

问题规模 n 为待插入元素的数组长度。

时间复杂度分析：
最好的情况是删除表尾元素，不需要移动数组中原本的元素，时间复杂度为O(1)。
最坏的情况是删除表头元素，需要移动数组中原本的n-1个元素，时间复杂度为O(n)。
平局情况下，假设删除任何位置的元素的概率p都相同，i=0,1,⋯n-1，共n个位置，则p=1/n。即当i=0，循环n-1次；i=1，循环n-2次，⋯，i=n-2，循环1次；i=n-1，循环0次，所以平均循环次数=(n-1)p+(n-2)p+⋯+p=(1+2+⋯+n-1)/n=(n-1)/2，故时间复杂度为O(n)。

#### 线性表的查询

按值查询，返回下标：

```c
// SeqList L 表示查询元素的数组
// int i 表示待查询元素在数组中的索引
ElemType GetItem(SeqList L, int i) {
	return L.data[i];
}
```

按值查询，返回下标：

```c
// SeqList L 表示查询元素的数组
// int i 表示待查询元素的值
int LocateElem(SeqList L, int e) {
	for (int i = 0; i < L.length; i++) {
		if (L.data[i] == e) return i;
	}
    // 可以用 -1 表示无值
	return 0;
}
```

#### 线性表的链式存储—单链表

之前介绍的线性表都是顺序存储的，顺序表的物理结构还可以是链式存储：

```c
typedef struct Node{
	ElemType data; // 
	Struct Node *next;
}Node,*LinkList; /* LinkList 为该结构的指针类型*/
```

`data` 为数据域，存放数据元素；`next`为指针域，存放其后继结点的地址。

链表可分为带头结点和不带头结点的。为了操作的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。

头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点。

引入头结点的优点：链表的第一个位置上的操作和在表的其他位置上的操作一致，空表和非空表的处理得到了统一。

#### 线性表的链式存储—双向链表

```c
typedef struct Node{
	ElemType data; // 
	Struct Node *prior,*next;
}Node,*LinkList;
```

#### 静态链表

以上介绍的链表都是使用指正类型实现，链表节点空间的分配和回收是由系统提供标准函数`malloc`和`free`动态实现的，故称之为动态链表。而一些高级语言中没有提供指针这种数据类型，若想采用链表左存储结构，需采用**顺序存储结构**数组来模拟实现链表。

```c
#define MAXSIZE 10
typedef struct Node {
	int data; 
	int next;
}StaticList[MAXSIZE];
```

注意：初始化时应将

优点：增删操作不需要大量移动元素。

缺点：不能随机存取且容量固定不变。

#### 顺序表和链表的比较

顺序表和链表的逻辑结构都是线性结构，都属于线性表。

二者的存储结构不同，顺序表为顺序存储，优点是支持随机存取、存储密度高，缺点是大片连续空间分配不方便，改变容量不方便；链表为链式存储，优点是改变容量方便，缺点是不可随机存取，存储密度低。

初始化时，顺序表需要预分配连续空间，若分配空间过小，则之后不方便扩展容量；若分配空间过大，则浪费内存资源；链表只需预先分配一个头结点以方便之后的扩展，或只声明一个头指针。

插入或删除元素时，顺序表需要将所插入或删除元素的后续元素进行后移或前移，时间复杂度为O(n)，时间开销主要来自移动元素。链表的插入或删除只需修改指针即可，时间复杂度为O(n)，时间开销主要来自查找元素，如果单个数据元素很大，使用链表的插入或删除的效率优于使用顺序表。

查找元素时，顺序表按位查找时间复杂度为O(1)，按值查找为O(n)，如果有序可在O(log<sub>2</sub>n)时间内找到；链表查找的时间复杂度为O(n)，效率低于使用顺序表。

销毁时，顺序表直接赋值为`NULL`由系统自动回收，而链表因为由`malloc`生成在堆区，需要使用`free`进行销毁。

|                | 顺序表 |  链表  |
| :------------: | :----: | :----: |
| 弹性（可扩容） |   差   |   高   |
|     增、删     | 效率低 | 效率高 |
|       查       | 效率高 | 效率低 |

#### 栈

栈是只允许在一段进行插入或删除操作的线性表。栈又称为后进先出（Last In First Out，LIFO）的线性表。

允许插入和删除的一段称为栈顶。不允许插入和删除的一端称为栈底。
$$
\begin{aligned}
&有n个不同元素进栈，由于在进栈的同时可能也会有出栈操作，合法出栈元素不同排列的个数为：\frac{1}{n+1}C^n_{2n}，
\\
&这个式子称为卡特兰数，可用数学归纳法证明。
\end{aligned}
$$

栈非常重要的一个应用就是在程序设计语言中用来实现递归。递归是指定义吱声同时又出现了对自身的应用。

#### 队列

队列是一种线性表，它只允许在表的一端插入元素，而在另一端删除元素，所以队列具有先进先出（First In First Out，FIFO）的特性。

##### 循环队列

循环队列是队列的一种顺序表示和实现方法。队列非空时 front 指向队头元素，rear **可能**指向队尾元素或队尾元素的后一个位置。

在队列非空时 front 指向队头元素，rear 队尾元素的后一个位置未前提，判断队列空与满方法的条件：

* 牺牲一个单元来区分队空和队满

  队空：`front==rear`，队满：`front==(rear+1) % MAXSIZE`

* 增加`size`变量，用来表示元素个数

  队空：`size==0`，队满：`size== MAXSIZE`

* 增加`tag`变量，用以区分最后执行的操作是入队还是出队，可在出队后将`tag`赋值为0；入队时，`tag`为1

  队空：`front==rear&&tag==0`，队满：`front==rear&&tag==1`

##### 链队列

用链表表示的队列简称为链对列。为了方便操作，这里采用带头结点的链表结构，并设置了一个对头指针`front`和一个队尾指针`rear`。对头指针始终指向头结点，队尾指针指向最后一个元素。

#####  双端队列

双端队列是允许两端都可以进行入队和出队操作的队列。

设有一个双端队列，输入序列为x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，x<sub>4</sub>，则由输入受限的双端队列无法得到的序列为x<sub>4</sub>，x<sub>2</sub>，x<sub>1</sub>，x<sub>3</sub>与x<sub>4</sub>，x<sub>2</sub>，x<sub>3</sub>，x<sub>1</sub>；由输出受限的双端队列无法得到的序列为x<sub>4</sub>，x<sub>1</sub>，x<sub>3</sub>，x<sub>2</sub>与x<sub>4</sub>，x<sub>2</sub>，x<sub>3</sub>，x<sub>1</sub>。

设有一个双端队列，如果先按x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，x<sub>4</sub>，...，x<sub>n</sub>顺序入队后，再进行出队操作，出队时x<sub>1</sub>，x<sub>2</sub>必定相邻。

扩展：设有n个只允许一端插入元素，在另一端删除元素的队列，当通过依次输入8，4，2，5，3，9，1，6，7且每个元素可以输入到这n个队列的任意一个，若期望输出顺序为1，2，3，4，5，6，7，8，9，则n至少为 4。（思路：输入时要确保后输入的比前一个输入的要大，且两者尽量的差距尽量小）

#### 串

字符串是一种特定的线性表，其特殊性在于组成线性表的每个元素就是一个单字符。

字符串是由零个或多个字符组成的有限序列。记为：S='a<sub>1</sub>a<sub>2</sub>...a<sub>n</sub>'（n>0），其中S是串的名字，用单引号括起来的字符序列是串的值。

需要特别指出的是，串值必须用一对但引号括起来（C语言中时双引号），但引号是界限符，它不属于串，其作用是避免串值与变量名或常量混淆。

子串：串中任意个连续的字符组成的子序列称为该串的子串。

主串：包含子串的称为主串。

子串在主串的位置：通常将字符在串中的序号称为该字符在串中的位置。子串在主串的位置则以子串的第一个字符在主串中的位置来表示。

串的基本操作通常以子串作为操作对象。

串的前缀：包含第一个字符，且不包含最后一个字符的子串。

串的后缀：包含最后一个字符，且不包含第一个字符的子串。

只有一个字符的串前后缀不存在。

#### 数组

从逻辑结构上，数组可以看成是对一般线性表的扩充。一维数组即为线性表，而二维数组可以定义为"其数据元素为一维数组"的线性表。

数组采用顺序存储，可以按行序存储，也可以按列序存储。C语言中以行序为主存储。

1）一维数组的地址计算

设一维数组为A=a<sub>1</sub>，a<sub>2</sub>，⋯，a<sub>n</sub>，数组中每个元素占 size 个存储单元，则元素a<sub>i</sub>的存储地址为：
$$
Loc（A[i]）=Loc(A[1])+(i-1)×size
$$
2）二维数组的地址计算

a<sub>ij</sub>是排在第i行、第j列，且i，j=1，2，⋯，n，数组中每个元素占 size 个存储单元，如果按行序存储，则元素a<sub>ij</sub>的存储地址为：
$$
Loc（A[i][j]）=Loc(A[1][1])+((i-1)×n+j-1)×size
$$
3）三维数组的地址计算

三维数组A[1..r,1..m,1..n]可以看成是r个m×n的二维数组。

数组中每个元素占 size 个存储单元，如果按行序存储，则元素a<sub>ijk</sub>的存储地址为：
$$
Loc（A[i][j][k]）=Loc(A[1][1][1])+((i-1)×m×n+(j-1)×n+(k-1))×size
$$

#### 特殊矩阵的压缩存储

1）下三角矩阵

a<sub>ij</sub>是排在第i行、第j列，且i，j=1，2，⋯，n，数组中每个元素占 size 个存储单元，如果按行序存储，则元素a<sub>ij</sub>的存储地址为：
$$
Loc（A[i][j]）=Loc(A[1][1])+(\frac{i(i-1)}{2}+(j-1))×size
$$
2）带状矩阵（三对角矩阵）

a<sub>ij</sub>是排在第i行、第j列，且i，j=1，2，⋯，n，数组中每个元素占 size 个存储单元，如果按行序存储，则元素a<sub>ij</sub>的存储地址为：
$$
Loc（A[i][j]）=Loc(A[1][1])+(2×(i-1)+j-1)×size
$$
带状矩阵除第一行与最后一行只有两个元素，其余行都有三个元素，所以前(i-1)行有3(i-1)-1个元素。而a<sub>ij</sub>所在列，其前又有j-i+1个元素。

### 应用

#### 表达式求值

任何一个表达式都是由一个运算对象、运算符和界限符组成的。

##### 中缀表达式求值

中缀表达式求值需要先

转为前缀表达式或后缀表达式，再进行求值。

##### 中缀表达式转后缀表达式

初始化一个运算符栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：

1）遇到操作数。直接加入后缀表达式中
2）遇到界限符。遇到"("直接入栈；遇到")"则依次弹出栈内运算符并加入后缀表达式（不用考虑优先级了），直到弹出"("为止。注意：后缀表达式中没有括号
3）遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，直到遇到"("、栈空或低优先级的运算符

##### 前缀表达式求值

初始化一个运算数栈，用于保存暂时还不能确定运算顺序的运算数。从右到左处理各个元素，直到末尾。可能遇到两种情况：

1）遇到运算数。直接入栈。
2）遇到运算符。依次弹出右操作数和左操作数进行运算后再入栈。

##### 后缀表达式求值

初始化一个运算数栈，用于保存暂时还不能确定运算顺序的运算数。从左到右处理各个元素，直到末尾。可能遇到两种情况：

1）遇到运算数。直接入栈。
2）遇到运算符。依次弹出右操作数和左操作数进行运算后再入栈。

#### KMP 算法

1）求next数组

由模式串的索引为 0~j-1 的字符所组成的串记为 S，则 next[j]= S 的最大相等前后缀的长度+1

规定next[0]=-1

2）求nextVal数组

因为求得的next数组中可能存在相同元素的对应的索引在next中的值不同，而在回溯时又重复比较，这是可以优化的，避免重复比较。

# 第三章 广义表

广义表（又称列表）是 n ≥0 个元素 a<sub>0</sub>， a<sub>1</sub>，⋯， a<sub>n-1</sub>的有限序列，其中每一个a<sub>i</sub>是原子或广义表。

当广义表非空时，广义表的表头指第一个元素，而广义表的表尾指除表头之外的其它元素组成的表。

广义表的深度值该广义表展开后所含括号的重数。

```
A=() 空表，长度为0，深度为1，无表头、表尾
B=(()) 长度为1，深度为2，表头为()，表尾为()
C=(a,(b,c)) 长度为2，深度为2，表头为a，表尾为((b,c))
D=(a,D) 长度为2，深度为无穷，表头为a，表尾为(D)
```

# 第四章 树

树是n（n ≥0 ）个结点的有限集。当 n=0 时，称为空树。

除根结点外的所有结点有且只有一个前驱。

树中所有结点可以有零个或多个后继。

结点的度：树中一个结点的直接后继个数（一个结点的子树个数）。树中的结点数等于所有结点的度数之和加1.

结点的层次：从根结点开始定义，根结点的层次为1，根的直接后继的层次为2，依此类推

结点的高度：从叶子结点开始自底向上逐层递增的。

结点的深度：从根结点开始自顶向下逐层递增的。

双亲结点：一个结点的直接前驱称为该结点的双亲结点。

树的度：各结点的度的最大值。

树的路径长度是指根结点到每个结点的路径长的总和。

逻辑上看，树中结点的各子树从左到右是有次序的，不能互换，这种树称为有序树，否则称为无序树。

### 二叉树

二叉树允许空二叉树存在，即没有结点。
$$
设非空二叉树中度为0、1和2的结点个数分别为n_0、n_1和n_2，则n_0=n_2+1。（叶子结点比二分支结点多一个）\\
具有n个(n>0)结点的完全二插树的高度h为[log_2(n+1)]huo[log_2n]+1\\
高度为h的m叉树至多有:m^0+m^1+⋯+m^{(h-1)}=\frac{1-m^h}{1-m}个结点\\
高度为h、度为m的树至少有 h+m-1个结点
$$
具有n个结点的m叉树的高度n，n满足下列不等式：
$$
\begin{aligned}
&前h-1层最多结点数\hspace{0.5cm} \frac{1-m^{h-1}}{1-m}<n≤\frac{1-m^{h}}{1-m}\hspace{0.5cm}前h层最多结点数
\end{aligned}
$$

#### 满二叉树

<img src=".\pictures\full binary tree.png" alt="full binary tree" style="zoom:50%;" />

对于高度为h的满二叉树，其具有如下性质：

* 结点数为2<sup>h</sup>-1
* 是完全二叉树
* 只有最后一层有叶子结点
* 没有度为1的结点

#### 完全二叉树

<img src=".\pictures\complete binary tree.png" alt="complete binary tree" style="zoom:50%;" />

对于高度为h的完全二叉树二叉树，其具有如下性质：

* 最后两层可能出现叶子结点
* 结点序号与高度为h的满二叉树中的结点一一对应（简单来说，结点从左往右依次添加，不允许跳跃）
* 最多只有一个度为1的结点
* i ≤ n/2为分支结点，i > n/2 为叶子结点
* i结点的左孩子2i（2i≤n），右孩子为2i+1（2i+1≤n）

#### 二插排序树

左子树上的所有结点的关键字都小于根结点的关键字。右子树上的所有结点的关键字都大于根节点。

其余详见第六章。

#### 平衡二叉树

树上任一结点的左子树和右子树的深度之差不超过1。

### 存储方式

#### 顺序存储

二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左向右存储**完全二叉树**的结点元素。因为完全二叉树中结点的序号可以唯一地反映结点之间逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。

#### 链式存储

由于顺序存储在存储非完全二叉树是，空间利用率较低，因此二叉树一般采用链式存储结构。二插链表至少包含三个域：数据域、左指针域、右指针域。

在含有n个结点的二插链表中，含有n+1个空链域。

### 线索二叉树

在普通二叉树结点的基础上，增加了两个标志位`ltag`和`rtag`。`ltag`==1是，表示`lchild`指向前驱；`ltag==0`时，表示`lchild`指向左孩子。`rtag`==1是，表示`rchild`指向后继；`rtag==0`时，表示`rchild`指向右孩子。

注意，这里的前驱与后继，指遍历序列的前后关系。

### 二插树的遍历

1）先序遍历（DLR）操作过程

若二叉树为空，则为空操作，否则依次执行如下三个操作：

* 访问根结点
* 按先序遍历访问左子树
* 按先序遍历访问右子树

2）中序遍历（LDR）操作过程

* 按中序遍历访问左子树
* 访问根结点
* 按中序遍历访问右子树

3）后序遍历（LRD）操作过程

* 按后序遍历访问左子树
* 按后序遍历访问右子树
* 访问根结点

4）层序遍历

从左到右，从上到下依次访问

下图，先序遍历的结果：ABDGCEF，中序遍历的结果：DGBAECF，后序遍历的结果：GDBEFCA，层序遍历的结果：ABCDEFG。

<img src="C:\Users\Administrator\Desktop\_posts\考研\数据结构\pictures\tree traversal.png" alt="tree traversal" style="zoom:80%;" />

由二叉树的遍历构造二插树：1.前序+中序；2.后序+中序；3.层序+中序。

### 树的遍历

1）先根遍历

若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的原则。

先根遍历序列与这可树的相应二叉树的先序序列相同。

2）后根遍历

若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的原则。

后根遍历序列与这可树的相应二叉树的中序序列相同。

### 森林的遍历

1）先序遍历

若森林为非空，则按如下规则进行遍历：

* 访问森林中第一课树的根结点
* 先序遍历第一棵树中根结点的子树森林
* 先序遍历除去第一课树之后剩余的树构成的森林

森林的先序遍历与森林相应的二叉树的先序序列相同。

2）中序遍历

若森林为非空，则按如下规则进行遍历：

* 访问森林中第一课树的根结点
* 中序遍历第一棵树中根结点的子树森林
* 中序遍历除去第一课树之后剩余的树构成的森林

森林的中序遍历与森林相应的二叉树的中序序列相同。

### 树、二叉树、森林之间转化

采用孩子兄弟表示法：

```c
typedef struct CSNode {
	int data;
	struct CSNode* firstChild, * nextSibling;
}CSTNode, * CSTree;
```

### 哈夫曼树

在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二插树称为哈夫曼树（又称最优二叉树）。

哈夫曼树不唯一。

### 哈夫曼编码

固定长度编码：对每个字符用相等长度的二进制表示。

可变长度编码：允许对不同字符用不等长的二进制为表示。

前缀编码：若没有一个编码的前缀时另一个编码的前缀，则成这样的编码为前缀编码。

哈夫曼编码：字符集中的每个字符作为哈夫曼树的一个叶子结点，各个字符出现的品读作为结点的权值。哈夫曼编码不唯一。哈夫曼编码可用于数据压缩。

# 第五章 图

### 概念

线性表可以是空表，树可以是空树，但图不能为空。图的顶点集一定非空，但边集可以为空。

##### 有向图

若E是有向边（也称为弧）的有限集合时，则称图G为有向图。

弧的顶点的有序对，记为<v,w>，其中v,w是顶点，v称为弧尾，w称为弧头，<v,w>称为从v到w的弧，也称v邻接到w。

##### 无向图

若E是无向边（简称边）的有限集合时，则称图G为无向图。

边的顶点的无序对，记为<v,w>或<w,v>，其中v,w是顶点，可以说w和v互为邻接点，边<v,w>依附于v和w，也称边<v,w>和v,w相关联。

##### 连通图

在**无向图**中，若从顶点v到顶点w有路径存在，则称v和w是联通。

若图G中任意两个顶点都是连通的，则成图G为连通图，费泽称为非连通图。

无向图中的极大连通子图称为连通分量。

<img src=".\pictures\map.png" alt="map" style="zoom:50%;" />
$$
对于n个顶点的无向图G，若G是连通图，则最少有n-1条边；若G是非连通图，则最多有C^2_{n-1}条边。
$$
连通图的生成树是包含图中全部顶点的一个极小连通子图。

在非联通图中，连通分量的生成树构成了非连通图的生成森林。

##### 强连通图

在**有向图**中，如果有一堆顶点v和w，从v到w和从w到v之间都有路径，则成这两个顶点是强连通的。

若图中任何一堆顶点都是强连通的，则称此图为强连通图。

有向图中的极大连通子图称为强连通分量。

对于n个顶点的有向图G，若G是强连通图，则最少有n条边。

##### 完全图

有 n(n-1)/2 条边的无向图称为无向完全图。在无向完全图中，任意两个顶点之间都存在边。

有 n(n-1) 条边的有向图称为有向完全图。在有向完全图中，任意两个顶点之间都存在方向相反的两条弧。

##### 子图

设有两个图G=（V,E）和G'=（V',E'），若V‘是V的子集，且E’是E的子集则称G‘是G的子图。

##### 生成子图

设有两个图G=（V,E）和G'=（V',E'），若V‘=V，且E’是E的子集，则称G‘是G的生成子图。

##### 网

在一个图中，每条边都可标上具有某种含义的数值，该数值称为该边的权值。这种边上待有权值的图称为带权图，也称网。

##### 度

在无向图中，顶点v的度是指依附于顶点v的边的条数，记为TD(v)。

对于具有n个顶点、e条边的无向图，全部顶点的度的和等于边数的两倍。

在有向图中，顶点v的度分为入度和出度，入度是以顶点v为终点的有向边的数目，记为ID(v)。出度是以顶点v为起点的有向边的数目，记为OD(v)。

对于具有n个顶点、e条边的有向图，全部顶点的出度的和=全部顶点的入度的和=边数。



路径：顶点v<sub>p</sub>到v<sub>q</sub>之间的一条路径是指顶点序列。

简单路径：在路径序列中，顶点不重复出现的路径。

路径长度：路径上边的数目称为路径长度。

回路：第一个顶点和最后一个顶点相同的路径称为回路或环。

简单回路：出第一个顶点和最后一个顶点外，其余顶点不重复出现的回路。

距离：从顶点u触发到顶点v的最短路径若存在，则此路径的程度称为动u到v的距离。若从u到v根本不存在路径，则记该距离为无穷。

### 图的存储

##### 邻接矩阵（Adjacency Matrix）表示法

```c
#define MAX_VERTEX_NUM 100
typedef struct  {
	char vertex[MAX_VERTEX_NUM]; // 顶点
	int arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; // 邻接矩阵
	int vexnum,arcnum; // 图的顶点数和弧数
}AdjMatrix;
```

下图中，第i行第j列如果为1，表示两顶点连通，否则不连通。如果为有向图，则行代表起点，列为终点，1和0代表是否连通。

<img src="C:\Users\Administrator\Desktop\_posts\考研\数据结构\pictures\AdjMatrix.png" alt="AdjMatrix" style="zoom:50%;" />

无向图的邻接矩阵是对称矩阵，可以使用压缩存储。

邻接矩阵的性质：设图G的邻接矩阵A（矩阵元素为0或1），则A<sup>n</sup>的元素A<sup>n</sup>\[i\]\[j\]等于由顶点i到顶点j的长度为n的路径的数目。

数组实现的顺序存储，空间复杂度高，不适合存储稀疏图。

图的邻接矩阵表示方式唯一。

##### 邻接表（Adjacency List）表示法

```c
#define MAX_VERTEX_NUM 100
typedef struct ArcNode {
	int adjvex; // 该户指向顶点的位置
	struct ArcNode* nextarc;
	// otherInfo info; // 其它信息
}ArcNode;

typedef struct VertexNode {
	int data; // 顶点数据
	ArcNode* firstarc; // 指向该顶点第一条弧的指针
}VertexNode;

// DG 表示有向图，DN 表示有向网，UDG便是无向图，UDN表示无向网
typedef enum {DG,DN,UDG,UDN} GraphKind;

typedef struct {
	VertexNode vertex[MAX_VERTEX_NUM]; 
	int vexnum, arcnum; // 图的顶点数和弧数
	// GraphKind kind; //  用于记录图的种类标志
}AdjList;
```

<img src=".\pictures\Adjacency List.png" alt="1" style="zoom:50%;" />

有向图的空间复杂度：O(|V|+|E|)

无向图的空间复杂度：O(|V|+2|E|)

图的邻接表的表示方式不唯一。

1）无向图的度

在无向图的邻接表中，顶点 v<sub>i </sub> 的度恰好就是第i个单链表上结点的个数。

2）有向图的度

在有向图中，第 i 个单链表上结点的个数只是顶点 v<sub>i </sub> 的出度。

要求第 i 个顶点的入度，必须遍历整个邻接表。可以再构建一逆邻接表，逆邻接表中第 i 个单链表上结点的个数为顶点 v<sub>i </sub> 的入度。

##### 十字链表法

十字链表（Orthogonal List）是**有向图**的另一种链式存储结构，可以把它看成是将有向图的邻接表和逆邻接表结合起来的一种链表。

<img src=".\pictures\Orthogonal List.png" alt="Adjacency List" style="zoom:50%;" />

图的十字链表的表示方式不唯一。

##### 邻接多重表

邻接多重表（Adjacency Multi-list）是**无向图**的另外一种存储结构。

理解即可，不会出手写代码。

图的邻接多重表的表示方式不唯一。

### 图的遍历

##### 广度优先

空间复杂度：O(|V|)

1）邻接矩阵存储的图

访问 |V| 个顶点需要O(|V|)的时间；查找每个顶点的邻接点都需要O(|V|)的时间，查找完所有顶点需要O(|V|<sup>2</sup>)的时间。

时间复杂度：O(|V|<sup>2</sup>)。

2）邻接表存储的图

访问 |V| 个顶点需要O(|V|)的时间；查找每个顶点的邻接点都需要O(1)的时间，查找完所有顶点需要O(|E|)的时间。

时间复杂度：O(|V|+|E|)。

##### 深度优先的空间与时间复杂度与广度优先相同

### 图的应用

##### 最小生成树

1）普利姆（Prim）算法

从某一个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，知道所有顶点都纳入为止。

时间复杂度：O(|V|<sup>2</sup>)，适合用于边稠密图。

2）克鲁斯卡尔（Kruskal）算法

每次选择一条权值最小的边，使这条边的两端连通（原本已经连通的就不选）。

时间复杂度：O(|E|log<sub>2</sub>|E|)，适合用于边稀疏图。

##### 最短路径

1）广度优先算法（BFS）算法

仅用于计算无权图（或权都相同）的单源最短路径问题

2）Dijkstra算法

设置两个辅助数组：1.dist[]：记录从源点 v<sub>0</sub> 到其它各顶点当前的最短路径长度，它的出态为：若从  v<sub>0</sub> 到 v<sub>1</sub> 有弧，则 dist[i] 为弧上的权值；否则置 dist[i] 为 ∞。2.path[]：path[i] 表示从源点到顶点 i 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 v<sub>0</sub> 到顶点  v<sub>i</sub> 的最短路径。

注意：Dijkstra算法不适用于有负权值的带权图。

时间复杂度：O(V<sup>2</sup>)

不考手写代码。

3）Floyd算法

时间复杂度：O(n<sup>3</sup>)

空间复杂度：O(n<sup>2</sup>)

注意：Floyd算法适用于有负权值的带权图，但解决不了环路中有负权值的带权图。

##### 有向无环图描述表达式、

有向无环图简称 DAG 图。

<img src=".\pictures\Directed acyclic graphs describe expressions.png" alt="Directed acyclic graphs describe expressions" style="zoom:50%;" />

##### 拓扑排序

若用 DAG 图（有向无环图）表示一个工程，其顶点表示活动，用有向边 <V<sub>i</sub>,V<sub>j</sub>>表示活动V<sub>i</sub>必须先于活动V<sub>j</sub>进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为 AOV （Activity On Vertex NetWork）网。

拓扑排序的实现：
1.从AOV网中选择一个没有前驱的顶点并输出
2.从网中删除该顶点和所有已它为起点的有向边
3.重复1和2知道当前AOV网为空或当前网中不存在无前驱的顶点为止。

邻接矩阵的时间复杂度：O(|V|<sup>2</sup>)，邻接表的时间复杂度：O(|V|+|E|)。

每个AOV网可能有多个拓扑排序序列。

##### 关键路径

在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为用边表示活动的网络，简称 AOE （Activity On Edge NetWork）网。

在 AOE 网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始。

在 AOE 网中仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。

从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。

事件 v<sub>i</sub> 的最早发生时间 ve(i)：从源点到顶点 v<sub>i</sub> 的**最长**路径的长度，称为事件 v<sub>i</sub> 的最早发生时间。

事件 v<sub>i</sub> 的最晚发生时间 vl(i)：在保证汇点按其最早发生时间发生这一前提下，求事件 v<sub>i</sub> 的最晚发生时间。

图中可能存在多条关键路径，只缩短一条路径上的关键活动的时间，并不能缩短整个工程的工期。只有缩短那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。

但缩短到一定程度时，关键活动可能会变成非关键活动。

# 第六章 查找

### 顺序查找

适用于线性表（顺序表或链表），之前已介绍，这里略过。

ASL<sub>成功</sub>=(n+1)/2，ASL<sub>失败</sub>=n+1。

##### 顺序查找优化

如果线性表为有序表（顺序表或链表），则查找失败时可以不用再比较到表的另一端就能返回查找哦失败的信息，从而降低顺序查找失败的平均查找长度。

### 折半查找

折半查找又称二分查找。

仅适用于有序的顺序表。

ASL<sub>失败</sub>的时间复杂度：log(log<sub>2</sub>n)

折半查找判定树是一颗平衡二叉树，树高为[log<sub>2</sub>(n+1)]（不包含失败结点，如果包含失败结点还要再加1）

### 分块查找

分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点。适用于链表和顺序表。

分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块之间是有序的。
$$
\begin{aligned}
&假设，长度为n的查找表被均匀地分为b块，每块s个元素，\\
&设索引查找和块内查找的平均查找长度分别为L_I、L_S，则分块查找的平均查找长度为：ASL=L_I+L_S\\
&用顺序查找索引表，则L_I=\frac{1+2+⋯+n}{b}=\frac{1+b}{b},L_S=\frac{1+2+⋯+s}{s}=\frac{1+s}{s}，则\\
&ASL=\frac{1+b}{b}+\frac{1+s}{s}=\frac{1+\frac{n}{s}}{\frac{n}{s}}+\frac{1+s}{s}=\frac{s^2+2s+n}{2s}，当s=\sqrt{n}时，ASL最小，为\sqrt{n}+1\\
&用折半查找索引表，则ASL=[log_2(b+1)]+\frac{s+1}{2}
\end{aligned}
$$
不考手写代码。

### 二叉排序树

二插排序树又称二叉查找树（BST，Binary Search Tree）。

二叉查找树可以为空树。

左子树上所有结点的关键字均小于根结点的关键字。右子树上所有结点的关键字均大于根结点的关键字。左子树和右子树又各是一棵二叉排序树。

二叉排序树删除结点时，如果该结点只有一颗左子树或右子树，则让该结点的子树称为该结点的父节点的子树。
二叉排序树删除结点时，如果该结点有左子树和右子树，可以让该结点的中序遍历的前驱或后继来替代该结点。

时间复杂度最好O(log<sub>2</sub>n)，最坏O(n)

### 平衡二叉排序树

平衡二叉排序树简称（AVL树）。左右子树的高度差的绝对值不超过1.

LL：在A的左孩子的左子树中进行插入导致A不平衡，将A的左孩子右上旋（右上旋示因为原本A在A的左孩子的右上角）。

RR：在A的右孩子的右子树中进行插入导致A不平衡，将A的右孩子左上旋（左上旋示因为原本A在A的右孩子的左上角）。

<img src=".\pictures\RR.png" alt="RR" style="zoom:40%;" />

LR：在A的左孩子的右子树中进行插入导致A不平衡，将A的左孩子的右孩子先左上旋再右上旋。

<img src=".\pictures\LR.png" alt="LR" style="zoom:40%;" />

RL：在A的右孩子的左子树中进行插入导致A不平衡，将A的右孩子的左孩子先右上旋再左上旋。

假设以n<sub>h</sub>表示深度为h的平衡树中含有的最少结点数。则有n<sub>0</sub>=0，n<sub>1</sub>=1，n<sub>2</sub>=2，n<sub>h</sub>=n<sub>h</sub>+n<sub>h-1</sub>+1。

时间复杂度O(log<sub>2</sub>n)

### 散列表（哈希表）

同义词：若不同关键字通过散列函数映射到同一个值，则称它们为同义词。

通过散列函数确定的位置上已经存放了其它元素，则称这种情况为冲突。

##### 散列函数的构造方法

* 直接定值法

  直接取关键字的某个线性函数值为散列地址。

* 除留余数法

* 数字分析法

* 平方取中法

##### 处理冲突的方法

* 链地址法（拉链法，链接法）

  将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中。

  查找长度：在查找运算中，需要对比关键字的次数称为查找长度。

  注意，在此处存放指针，指针为NULL，存放的不是关键字，即待比较的关键字不存在，无需比较。

  <img src=".\pictures\hash search.png" alt="hash search" style="zoom:40%;" />
  $$
  ASL_{成功}=\frac{每条记录查找成功的查找长度之和}{表中记录数}=\frac{1×6+2×4+3×1+4×1}{12}=1.75\\
  ASL_{失败}=装填因子=\frac{表中记录数}{散列表的长度}=\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{13}=0.92
  $$
  
* 开放定址法

  删除元素时，应该进行逻辑删除，因为我们规定在查找时，移动后若遇到空则查找失败，如果进行硬删除，则可能我们要查找的元素在后边。

  * 线性探测法

    d<sub>i</sub>=1，2，⋯，n

  * 平方探测法

    d<sub>i</sub>=1<sup>2</sup>，-1<sup>2</sup>，2，-2<sup>2</sup>，⋯，n<sup>2</sup>，-n<sup>2</sup>，如果d<sub>i</sub>超过了表的长度，则从表的另一端开始循环计算。

    散列表长度 m 必须是一个可以表示成 4i+3 的素数，才能探测到散列表上的所有位置。

  * 伪随机探测再散列

    d<sub>i</sub>序列伪随机生成。

* 再哈希法（再散列法）

  有些教材将其归为开放定址法。

  准备多个散列函数，一个发生了冲突就用下一个。

# 第七章 排序

排序分为内部排序和外部排序。
内部排序：整个排序过程完全在内存中进行。
外部排序：外部排序由于待排序记录数据量太大，内存无法容纳全部数据，排序需要借助外部存储设备才能完成。

### 插入排序

每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。

### 希尔排序

希尔排序基于顺序表，不适用于链表，因为要通过增量实现随机访问。

希尔排序不稳定。

希尔排序的时间复杂度为O(n<sup>1.3</sup>)（记住即可）

当初始增量为1时，希尔排序退化为插入排序，时间复杂度为O(n<sup>2</sup>)

### 交换排序

##### 冒泡排序

适用于顺序表、链表。

如果在某一趟冒泡排序时没有发现一个逆序，则直接结束整个冒泡排序过程，此时额比较次数为 n-1 ，最好的时间复杂度为O(n)。

最坏情况下，比较次数= (n-1) + (n-2) + ⋯ +1 = (n-1)n/2，时间复杂度为O(n<sup>2</sup>)。

冒泡排序是稳定的。

##### 快速排序

把 n 个元素组织称二叉树，二叉树的层数就是递归调用的层数最少为[log<sub>2</sub>n]+1。

快速排序中每次划分进行比较，时间的复杂度为O(n)，而需要进行划分排序数为递归调用的层数。

若待排序的序列原本就是有序或逆序时，空间和时间的复杂度最高，不过可通过选择能把数据均分的元素作为枢轴来解决。

最好时间复杂度为O(nlog<sub>2</sub>n)，最坏时间复杂度为O(n<sup>2</sup>)，最好时间复杂度为O(nlog<sub>2</sub>n)。

最好空间复杂度O(log<sub>2</sub>n)，最坏空间复杂度为O(n)。

最好的

快速排序不稳定。

### 选择排序

##### 简单选择排序

适用于顺序表和链表。

空间复杂度O(1)，时间复杂度O(n<sup>2</sup>)。

##### 堆排序

大根堆（大顶堆）：二叉树中，根元素大于左孩子和右孩子。

小根堆（小顶堆）：二叉树中，根元素小于左孩子和右孩子。

结点每次向下交换，最多对比关键字两次，若树高为h，某结点在第 i 层，则该结点向下调整最多 h-i 层，关键字对比最多 2(h-i) 次。

建堆的过程，关键字对比次数不超过 4n，建堆时间复杂度为O(n)。每次向下调整，最多向下调整 [log<sub>2</sub>n] 次，时间复杂度为O(log<sub>2</sub>n)，所以总的时间复杂度为 O(n)+O(nlog<sub>2</sub>n)=O(nlog<sub>2</sub>n)。

空间复杂度O(1)。

堆排序不稳定。

### 基数排序

不考手写代码。

排序时先按最低位的值对记录进行初步排序，在此基础上再按次低位进行排序，以此类推。
$$
假设长度为n的线性表r中，r[i]的关键字为key_i=K^1_iK^2_i⋯K^d_i（例如key_2=23，K^1_2=2，K^2_i=3），其中0≤K^2_i≤r-1，r称为基数
$$
需要r个长度的数组，空间复杂度O(r)。

一次分配，时间花费O(n)；一次收集，时间花费O(r)；总共进行 d 次的分配与收集，所以时间复杂度：O(d(n+r))。

基数排序是稳定的。

基数排序适用于解决的问题：
1.数据元素的关键字可以方便地拆分为 d 组，且 d 较小
2.每组关键字的取值范围不大，即 r 较小
3.数据元素个数 n 较大

### 归并排序

归并排序是将两个或两个以上的有序表组合成一个新的有序表。

每趟归并时间复杂度为O(n)，归并趟树为[log<sub>2</sub>n]，归并排序由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均时间复杂度为O(nlog<sub>2</sub>n)。

空间复杂度O(n)+O(log<sub>2</sub>n)=O(n)

归并排序是稳定的。