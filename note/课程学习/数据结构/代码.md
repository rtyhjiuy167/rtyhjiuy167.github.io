# 线性表

### 顺序表

#### 静态分配

```c
#include<stdio.h>
#define MAXSIZE 10 

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}

// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引，从0开始
// int e 表示插入的元素
bool ListInsert(SeqList& L, int i, int e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false;

	for (int j = L.length - 1; j >= i; j--)  L.data[j + 1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}

// SeqList &L 表示待删除元素的数组
// int i 表示待删除元素在数组中的索引，从0开始
// int e 返回删除的元素
bool ListDel(SeqList& L, int i, int& e) {
	if (i<0 || i> L.length - 1) return false;
	e = L.data[i];
	for (int j = i; j <= L.length - 1; j++)  L.data[j] = L.data[j + 1];
	L.length--;
	return true;
}

// SeqList L 表示查询元素的数组
// int i 表示待查询元素在数组中的索引，从0开始
int GetItem(SeqList L, int i) {
	return L.data[i];
}

// SeqList L 表示查询元素的数组
// int i 表示待查询元素的值
int LocateElem(SeqList L, int e) {
	for (int i = 0; i < L.length; i++) {
		if (L.data[i] == e) return i;
	}
	// 可以用 -1 表示无值
	return 0;
}

void checkListInset(SeqList& seq) {
	ListInsert(seq, 0, 1);
	ListInsert(seq, 1, 2);
	for (int i = 0; i < seq.length; i++) printf("%d ", seq.data[i]);
}

void checkListDel(SeqList& seq) {
	ListInsert(seq, 0, 1);
	ListInsert(seq, 1, 666);
	int k;
	ListDel(seq, 1, k);// 删除索引为 0 的元素
	printf("%d", k); 
}

void checkGetItem(SeqList& seq) {
	ListInsert(seq, 0, 1);
	ListInsert(seq, 1, 666);
	printf("%d", GetItem(seq, 0)); // 从索引为0处取元素值
}

void checkLocateElem(SeqList& seq) {
	ListInsert(seq, 0, 1);
	ListInsert(seq, 1, 666);
	printf("%d", LocateElem(seq, 666)); // 获取值为 666 的元素的索引
}
int main(void) {
	SeqList seq;
	InitList(seq);
	//checkListInset(seq);
	//checkListDel(seq);
	//checkLocateElem(seq);
	//checkGetItem(seq);
	return 0;
}
```

#### 动态分配

```c
#include<stdio.h>
#include<malloc.h>

typedef struct {
	int* data; /*线性表占用的数组空间*/
	int MaxSize, length;  /*数组的最大容量和当前个数*/
}SeqList;/*动态分配数组顺序表的类型定义*/

int main(void) {
	SeqList seq;
	seq.MaxSize = 100;
	seq.length = 1;
	seq.data = (int*)malloc(sizeof(int) * 10);
	free(seq.data);
	return 0;
}
```

### 链式存储

#### 带头结点的单链表

```c
#include<stdio.h>
#include<malloc.h>

typedef struct Node {
	int data; // 
	struct Node* next;
}Node, * LinkList; /* LinkList 为该结构的指针类型*/


bool InitList(LinkList& L) {
	L = (Node*)malloc(sizeof(Node));
	// 内存不足，分配失败
	if (L == NULL) return false;
	L->next = NULL;
	return true;
}

bool isEmpty(LinkList L) {
	return L->next == NULL;
}

// 指定结点的后插操作
bool InsertNextNode(Node* p, int e) {
	if (p == NULL) return false;
	Node* n = (Node*)malloc(sizeof(Node));
	if (n == NULL) return false;
	n->data = e;
	n->next = p->next;
	p->next = n;
	return true;
}

// 指定结点的前插操作 实际上是替换该结点的数据域
bool InsertPreNode(Node* p, int e) {
	if (p == NULL) return false;
	Node* n = (Node*)malloc(sizeof(Node));
	if (n == NULL) return false;
	n->next = p->next;
	n->data = p->data;
	p->data = e;
	p->next = n;
	return true;
}

// int i 对应数组的索引，从0开始
bool ListInsert(LinkList& L, int i, int e) {
	if (i < 0) return false;
	Node* p = L; // 指针 p 指向当前扫描到的结点，初始时指向单链表的头结点
	int j = 0; // 指针 p 指向的待插入的结点前一个结点对应的索引位置，从0开始 

	// 将指针 p 移至待插入的前一个位置
	while (p != NULL && j < i) {
		p = p->next;
		j++;
	}
	return InsertNextNode(p, e);
}

// 删除指定序号的结点
// int i 按序号删除，从0开始
bool ListDel(LinkList& L, int i, int& e) {
	if (i < 0) return false;
	Node* p = L;
	int j = 0;

	// 将指针 p 移至待删除元素的前一个位置
	while (p != NULL && j < i) {
		p = p->next;
		j++;
	}
	if (p == NULL || p->next == NULL) return false;
	// 指针 q 指向下待删除的结点
	Node* q = p->next;
	e = q->data;
	p->next = q->next;
	free(q);
	return true;
}

// 删除指定的结点
// 思路：把该结点的下一个结点的数据域与指针域拿过来
bool NodeDel(Node* p) {
	if (p == NULL) return false;
	Node* q = p->next;
	// 无能力删除最后一个结点
	if (q == NULL) return false;
	p->data = p->next->data;
	p->next = q->next;
	free(q);
	return true;
}

void checkInsertPreNode(LinkList& L) {
	InsertPreNode(L, 0); // 给头结点插入了数据 0
	InsertPreNode(L->next, 1);
	InsertPreNode(L->next, 2);
	printf("%d %d", L->next->data, L->next->next->data);
}

void checkInsertNextNode(LinkList& L) {
	// 由于 L 指向头结点，所以向其后插入新结点没有改变头结点
	InsertNextNode(L, 1);
	InsertNextNode(L, 2);
	printf("%d %d", L->next->data, L->next->next->data);
}

void checkListInsert(LinkList& L) {
	ListInsert(L, 0, 123);
	ListInsert(L, 0, 432);
	printf("%d %d", L->next->data, L->next->next->data);
}

void checkListDel(LinkList& L) {
	ListInsert(L, 0, 123);
	ListInsert(L, 0, 432);
	int k;
	ListDel(L, 0, k);
	printf("%d", k);
}

int main(void) {
	LinkList L;
	InitList(L);
	//checkInsertPreNode(L);
	//checkInsertNextNode(L);
	//checkListInsert(L);
	//checkListDel(L);
	return 0;
}
```

#### 不带头结点的单链表

```c
#include<stdio.h>
#include<malloc.h>

typedef struct Node {
	int data;
	struct Node* next;
}Node, * LinkList;

bool InitList(LinkList& L) {
	L = NULL; // 空表，防止有之前的脏数据
	return true;
}

bool isEmpty(LinkList L) {
	return L == NULL;
}

bool insertNextNode(Node* p, int e) {
	if (p == NULL) return false;
	Node* n = (Node*)malloc(sizeof(Node));
	if (n == NULL) return false;
	n->data = e;
	n->next = p->next;
	p->next = n;
	return true;
}

// LinkList& L 不带头结点的单链表
// int i 表示插入元素所对应的索引位置，从0开始
// int e 表示插入的元素
bool ListInsert(LinkList& L, int i, int e) {
	if (i < 0) return false;
	if (i == 0) {
		Node* n = (Node*)malloc(sizeof(Node));
		n->data = e;
		n->next = L;
		L = n;
		return true;
	}
	// 指针 p 指向当前扫描到的结点，初始时指向单链表的头结点
	Node* p = L;

	// 指针 p 指向的待插入的结点前一个结点对应的索引位置，从0开始，不过之前已经判断了0的位置，所以这里的初始值为1
	int j = 1;

	// 将指针 p 移至待插入的前一个位置
	while (p != NULL && j < i) {
		p = p->next;
		j++;
	}
	return insertNextNode(p, e);
}
int main(void) {
	LinkList L;
	InitList(L);
	ListInsert(L, 0, 123);
	ListInsert(L, 0, 432);
	ListInsert(L, 1, 333);
	printf("%d %d %d", L->data, L->next->data, L->next->next->data);
	return 0;
}
```

#### 带头结点的循环单链表

```c
#include<stdio.h>
#include<malloc.h>

typedef struct Node {
	int data; 
	struct Node* next;
}Node, * LinkList; /* LinkList 为该结构的指针类型*/

bool InitList(LinkList& L) {
	L = (Node*)malloc(sizeof(Node));
	if (L == NULL) return false;
	L->next = L;
	return true;
}

// 判断循环单链表是否为空
bool Empty(LinkList L) {
	return L->next == L;
}

int main(void) {
	LinkList L;
	InitList(L);
	return 0;
}
```

#### 带头结点的循环双链表

```c
#include<stdio.h>
#include<malloc.h>

typedef struct Node {
	int data;
	struct Node* prior, * next;
}Node, * LinkList;

bool InitList(LinkList& L) {
	L = (Node*)malloc(sizeof(Node));
	if (L == NULL) return false;
	L->next = L;
	L->prior = L;
	return true;
}

// 判断循环双链表是否为空和判断循环单链表是否为空的方法相同
bool Empty(LinkList L) {
	return L->next == L;
}

// 删除指定结点的后一个结点
bool DeleteNextNode(Node* p) {
	if (p == NULL) return false;
	Node* q = p->next;
	// 该结点无后结点
	if (q == NULL) return false;
	p->next = q->next;
	if (q->next != NULL) q->next->prior = p;
	free(q);
	return true;
}

void DestoryList(LinkList& L) {
	while (L->next != NULL) DeleteNextNode(L);
	free(L);
	L = NULL;
}
int main(void) {
	LinkList L;
	InitList(L);
	DeleteNextNode(L);
	return 0;
}
```

#### 静态链表

```c
#include<stdio.h>
#define MAXSIZE 10
typedef struct Node {
	int data; 
	int next;
}StaticList[MAXSIZE];

void InitList(StaticList L) {
	for (int i = 0; i < MAXSIZE-1; i++) L[i].next = -2;
	L[0].next = -1;
}

int main(void) {
	StaticList L;
	InitList(L);
	return 0;
}
```

#### 栈

##### 顺序存储的栈

```c
#include<stdio.h>
#define MAXSIZE 10

typedef struct {
	int data[MAXSIZE]; // 用静态数组存放栈元素
	int top; // 栈顶指针
}SeqStack;

void InitStack(SeqStack &S) {
	S.top = -1;
}
bool isEmpty(SeqStack S) {
	return S.top == -1;
}
bool Push(SeqStack& S, int x) {
	if (S.top == MAXSIZE - 1) return false;
	S.data[++S.top] = x; // 新元素入栈
	return true;
}

bool Pop(SeqStack& S, int& x) {
	if (S.top == -1) return false;
	x = S.data[S.top--]; // 出栈后让top减一
	return true;
}

int main(void) {
	SeqStack S;
	InitStack(S);
	return 0;
}
```

##### 链式存储的带头结点的栈

```c
#include<stdio.h>
#include<malloc.h>

typedef struct node{
	int data; 
	struct node* next;
}LinkStackNode,*LinkStack;

bool InitStack(LinkStack& S) {
	S = (LinkStackNode*)malloc(sizeof(LinkStackNode));
	if (S == NULL) return false;
	S->next = NULL;
	return true;
}

bool Push(LinkStack&S,int x){
	LinkStackNode* temp = (LinkStackNode*)malloc(sizeof(LinkStackNode));
	if (temp == NULL) return false;
	temp->data = x;
	temp->next = S->next;
	S->next= temp;
	return true;
}

bool Pop(LinkStack& S, int &x) {
	LinkStackNode* temp = S->next;
	if (temp == NULL) return false;
	S->next = temp->next;
	x = temp->data;
	free(temp);
	return true;
}

int main(void) {
	LinkStack S;
	InitStack(S);
	Push(S, 2);
	int i;
	Pop(S, i);
	printf("%d", i);
	return 0;
}
```

#### 队列

##### 循环队列

```c
#include<stdio.h>
#define MAXSIZE 10

typedef struct {
	int data[MAXSIZE]; // 用静态数组存放队列元素
	int front, rear; // 对头指针和队尾指针
}SeqQueue;

bool InitQueue(SeqQueue& Q) {
	Q.front = 0;
	Q.rear = 0;
	return true;
}
// 这里判空的条件是尾指针与头指针的值相同，不过需要牺牲一个存储单元
bool isEmpty(SeqQueue Q) {
	return Q.rear == Q.front;
}

// 入队
bool EnterQueue(SeqQueue &Q,int x) {
	if ((Q.rear+1) % MAXSIZE==Q.front) return false;
	Q.data[Q.rear] = x;
	// % MAXSIZE 的值永远比MAXSIZE小1，因为需要空出一个，来判断队列是否为空
	Q.rear = (Q.rear + 1) % MAXSIZE;
	return true;
}
// 出队
bool DeleteQueue(SeqQueue &Q, int &x) {
	if (Q.rear == Q.front) return false;
	x = Q.data[Q.front];
	Q.front = (Q.front + 1) % MAXSIZE;
	return true;
}

int main(void) {
	SeqQueue S;
	InitQueue(S);
	for (int i = 0; i < MAXSIZE - 1; i++) {
		EnterQueue(S, i);
	}
	for (int i = 0; i < MAXSIZE - 1; i++) {
		int temp;
		DeleteQueue(S, temp);
		printf("%d ", temp);
	}
	return 0;
}
```

##### 不牺牲存储单元的方法

```c
#include<stdio.h>
#define MAXSIZE 10

typedef struct {
	int data[MAXSIZE]; // 用静态数组存放队列元素
	int front, rear; // 对头指针和队尾指针
	int size; // 增加 size 变量记录队列长度
}SeqQueue;

bool InitQueue(SeqQueue& Q) {
	Q.front = 0;
	Q.rear = 0;
	Q.size = 0;
	return true;
}
bool isEmpty(SeqQueue Q) {
	return Q.size==0;
}

bool isFull(SeqQueue Q) {
	return Q.size == MAXSIZE;
}

// 入队
bool EnterQueue(SeqQueue &Q,int x) {
	if (isFull(Q)) return false;
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear + 1) % (MAXSIZE+1);
	Q.size++;
	return true;
}
// 出队
bool DeleteQueue(SeqQueue &Q, int &x) {
	if (isEmpty(Q)) return false;
	x = Q.data[Q.front];
	Q.front = (Q.front + 1) % (MAXSIZE + 1);
	Q.size--;
	return true;
}

int main(void) {
	SeqQueue S;
	InitQueue(S);
	for (int i = 0; i < MAXSIZE; i++) {
		EnterQueue(S, i);
	}
	for (int i = 0; i < MAXSIZE; i++) {
		int temp;
		DeleteQueue(S, temp);
		printf("%d ", temp);
	}
	return 0;
}
```

##### 链队列

```c
#include<stdio.h>
#include<malloc.h>

typedef struct Node {
	int data;
	struct Node* next;
}LinkQueueNode;


typedef struct {
	LinkQueueNode* front, * rear;
}LinkQueue;

// 帶头结点的链队列初始化
bool InitQueue(LinkQueue& Q) {
	LinkQueueNode *node = (LinkQueueNode*)malloc(sizeof(LinkQueueNode));
	if (node== NULL)return false;
	Q.front = Q.rear = node;
	Q.front->next = NULL;
}

bool IsEmpty(LinkQueue Q) {
	return Q.front == NULL;
}

bool EnterQueue(LinkQueue& Q, int x) {
	LinkQueueNode* NewNode = (LinkQueueNode*)malloc(sizeof(LinkQueueNode));
	if (NewNode == NULL)return false;
	NewNode->data = x;
	NewNode->next = NULL;

	// 待插入的新结点为新的尾结点，rear指向之前的尾结点，需要将之前的尾结点中指针域指向下一个结点，即新的尾结点
	Q.rear->next = NewNode;
	// 修改尾指针的指向，指向新的尾结点
	Q.rear = NewNode;
}

bool DeleteQueue(LinkQueue& Q, int &x) {
	if (Q.front == Q.rear) return false;
	// 由于 Q.front 指向头结点，Q.front->next 才是指向第一个元素
	LinkQueueNode* FirstElem = Q.front->next;
	x = FirstElem->data;
	Q.front->next = FirstElem->next;
	// 如果出队的是最后一个结点，需要修改尾指针
	if (FirstElem == Q.rear) Q.rear = Q.front;
	free(FirstElem);
	return true;
}

int main(void) {
	LinkQueue Q;
	InitQueue(Q);
	return 0;
}
```

#### 串

##### 顺序存储

```c
#include<stdio.h>
#include<string.h>
#define MAXLEN 40

typedef struct {
	char ch[MAXLEN];
	int length;
}SString;

typedef struct {
	int data[MAXLEN];
	int length;
}SeqList;

// 用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串，此处pos从0开始
bool SubString(SString& sub, SString s, int pos, int len) {
	if (pos + len > s.length) return false;
	for (int i = pos; i < pos + len; i++) sub.ch[i - pos] = s.ch[i];
	sub.length = len;
	return true;
}

// 若串 s 和 t 相等则返回0；若 s>t 则返回正数；若 s< t 则返回负数
int SubString(SString s, SString t) {
	for (int i = 0; i < s.length && i < t.length; i++) {
		if (s.ch[i] != t.ch[i]) return s.ch[i] - t.ch[i];
	}
	return s.length - t.length;
}

bool StrAssign(SString& s, char chars[]) {
	int length = strlen(chars);
	if (length > MAXLEN - 1) return false;
	for (int i = 0; i < length; i++) {
		s.ch[i] = chars[i];
	}
	s.length = length;
	return true;
}
// 朴素模式匹配算法 ， s为目标串（主串）,t为模式串（子串）
// 从主串 s 的下标 pos 其，串 t 第一次出现的位置，成功返回位置序号，失败返回 -1；pos从0开始
// 利用三个指针，i用于指向当前主串用于比较字符的位置，j用于指向当前主串用于比较的子串的首个字符位置，k指向当前用于比较的 t 串中的字符位置  
int StrIndex(SString s,  SString t,int pos=0 ) {
	int i = pos, j = pos, k = 0;
	while (i < s.length && j < t.length) {
		if (s.ch[i] == t.ch[k]) {
			i++;
			k++;
		}
		else {
			k = 0;
			j++;
			i = j;
		}
	}
	if (j >= t.length) return j;
	else return -1;
}


void GetNext(SString t, int next[]) {
	int i = 0, j = -1;
	next[0] = -1;
	while (i < t.length-1) {
		if (j ==-1 ||t.ch[i] == t.ch[j]) next[++i] = ++j;
		else j = next[j];
	}
}

void GetNextVal(SString t, int nextVal[]) {
	for (int j = 1; j < t.length; j++) {
		if (t.ch[nextVal[j]] == t.ch[j]) nextVal[j] = nextVal[nextVal[j]];
		else nextVal[j] = nextVal[j];
	}
}
int IndexKMP(SString s, SString t) {
	int i = 0, j = 0;
	int d = t.length;
	SeqList NextList;
	NextList.length = t.length;
	GetNext(t, NextList.data);
	GetNextVal(t, NextList.data);
	while (i < s.length && j < t.length) {

		// j == -1 ，即当回溯后的模式串的第一个元素与i指向的目标串中的某元素不匹配，指向目标串的指针 i 应该右移，同时将 j 置为 0
		// s.ch[i] == t.ch[j]，即当两字符匹配时，i 与 j 指针右移
		if (j == -1||s.ch[i] == t.ch[j]) {
			i++;
			j++;
		}
		// 当 i 指向的元素与 j 指向的元素不匹配时，指向模式串的指针 j 应该回溯
		else j = NextList.data[j];
	}
	if (j >= t.length) return i - t.length;
	else return -1;
}
int main()
{
	SString t, s;
	char tChars[] = "googlogooglegooglo";
	char sChars[] = "google";
	StrAssign(t, tChars);
	StrAssign(s, sChars);
	printf("commom:%d   KMP:%d", StrIndex(t, s), IndexKMP(t, s));
	return 0;
}
```

##### 链式存储

```c
#include<stdio.h>

typedef struct StringNode {
	char ch[4];
	struct StringNode* next;
}StringNode, *String;
```

# 树

### 顺序存储

```c
#include<stdio.h>
#define MAXSIZE 255

typedef struct{
	int value;
	bool isEmpty;
}TreeNode,Tree[MAXSIZE];

void InitTree(Tree &t) {
	for (int i = 0; i < MAXSIZE; i++) {
		t[i].isEmpty = true;
	}
}

int main()
{
	Tree t;
	InitTree(t);
	return 0;
}
```

### 链式存储

```c
#include<stdio.h>

typedef struct BiTNode {
	int data;
	struct BiTNode* lchild,*rchild;
}BiTNode,*BiTree;

int main()
{
	return 0;
}
```

#### 树的遍历

##### 先序遍历

```c
#include<stdio.h>
#define MAXSIZE 50

typedef struct {
	BiTree data[MAXSIZE]; // 用静态数组存放栈元素
	int top; // 栈顶指针
}SeqStack;

void InitStack(SeqStack& S) {
	S.top = -1;
}

bool isEmpty(SeqStack S) {
	return S.top == -1;
}

bool Push(SeqStack& S, BiTree x) {
	if (S.top == MAXSIZE - 1) return false;
	S.data[++S.top] = x;
	return true;
}

bool Pop(SeqStack& S, BiTree& x) {
	if (S.top == -1) return false;
	x = S.data[S.top--];
	return true;
}
typedef struct BiTNode {
	int data;
	struct BiTNode* lchild, * rchild;
}BiTNode, * BiTree;

void visit(BiTNode* node) {
}

// 先序遍历 递归
void PreOrderRecursion(BiTree root) {
	if (root != NULL) {
		visit(root);
		PreOrderRecursion(root->lchild);
		PreOrderRecursion(root->rchild);
	}
}

// 先序遍历 非递归
void PreOrder1Stack(BiTree root) {
	SeqStack s;
	InitStack(s);
	if (root == NULL) return;
	Push(s, root);
	while (!isEmpty(s)) {
		BiTNode* node;
		Pop(s, node);
		visit(node);
		// 由于栈后进先出，因实现的是先序遍历，应该左孩子后进
		if (node->rchild != NULL) Push(s, node->rchild);
		if (node->lchild != NULL) Push(s, node->lchild);
	}
}
int main()
{
	return 0;
}
```

##### 后序遍历

```c
#include<stdio.h>

typedef struct BiTNode {
	int data;
	struct BiTNode* lchild, * rchild;
}BiTNode, * BiTree;

void visit(int data) {
}

// 后序遍历
void PreOrderRecursion(BiTree tree) {
	if (tree != NULL) {
		PreOrderRecursion(tree->lchild);
		PreOrderRecursion(tree->rchild);
		visit(tree->data);
	}
}

// 统计叶子结点 后序遍历 分治法
int leaf_b(BiTree root) {
	int LeafCount;
	if (root == NULL)
		LeafCount = 0;
	else if ((root->lchild == NULL) && (root->rchild == NULL))
		LeafCount = 1;
	else /* 叶子数为左右子树的叶子数目之和 */
		LeafCount = leaf_b(root->lchild) + leaf_b(root->rchild);
	return LeafCount;
}

/* 后序遍历求二叉树的高度递归算法 */
int PostTreeDepth(BiTree bt) { 
	int hl, hr, max;
	if (bt != NULL) {
		hl = PostTreeDepth(bt->lchild); /* 求左子树的深度 */
		hr = PostTreeDepth(bt->rchild); /* 求右子树的深度 */
		max = hl > hr ? hl : hr; /* 得到左、右子树深度较大者*/
		return(max + 1); /* 返回树的深度 */
	}
	else return(0); /* 如果是空树，则返回0 */
}

int main()
{
	return 0;
}
```

##### 层序遍历

```c
#include<stdio.h>
#include<malloc.h>

typedef struct Node {
	BiTNode* data;
	struct Node* next;
}LinkQueueNode;

typedef struct {
	LinkQueueNode* front, * rear;
}LinkQueue;

bool InitQueue(LinkQueue& Q) {
	LinkQueueNode* node = (LinkQueueNode*)malloc(sizeof(LinkQueueNode));
	if (node == NULL)return false;
	Q.front = Q.rear = node;
	Q.front->next = NULL;
}

bool isEmpty(LinkQueue Q) {
	return Q.front == NULL;
}

bool EnterQueue(LinkQueue& Q, BiTree x) {
	LinkQueueNode* NewNode = (LinkQueueNode*)malloc(sizeof(LinkQueueNode));
	if (NewNode == NULL)return false;
	NewNode->data = x;
	NewNode->next = NULL;
	Q.rear->next = NewNode;
	Q.rear = NewNode;
}

bool DeleteQueue(LinkQueue& Q, BiTree x) {
	if (Q.front == Q.rear) return false;
	LinkQueueNode* FirstElem = Q.front->next;
	x = FirstElem->data;
	Q.front->next = FirstElem->next;
	if (FirstElem == Q.rear) Q.rear = Q.front;
	free(FirstElem);
	return true;
}


typedef struct BiTNode {
	int data;
	struct BiTNode* lchild, * rchild;
}BiTNode, * BiTree;

void visit(BiTNode* node) {
}

void LevelOrder(BiTree T) {
	LinkQueue Q;
	InitQueue(Q);
	BiTNode *p;
	EnterQueue(Q, T);
	while (!isEmpty(Q)) {
		DeleteQueue(Q, p);
		visit(p);
		if (p->lchild != NULL) EnterQueue(Q, p->lchild);
		if (p->rchild != NULL) EnterQueue(Q, p->rchild);
	}
}
int main()
{
	return 0;
}
```

#### 树的线索化

##### 先序遍历

```c
#include<stdio.h>

typedef struct ThreadNode {
	int data;
	struct ThreadNode* lchild, * rchild;
	int ltag, rtag;
}ThreadNode, * ThreadTree;

void CreatePreThread(ThreadTree T) {
	ThreadNode* pre = NULL;
	if (T != NULL) {
		PreThread(T, pre);
		if (pre->rchild = NULL) pre->rtag = 1;
	}
}

// 先序遍历构建线索二叉树
void PreThread(ThreadTree T, ThreadNode* pre) {
	if (T != NULL) {
		visit(T, pre);
		// 由于先根后左，需要判断左的lchild为左孩子还是前驱，避免死循环
		if (T->ltag == 0) PreThread(T->lchild, pre);
		PreThread(T->rchild, pre);
	}
}

void visit(ThreadNode* node, ThreadNode* pre) {
	// 建立前驱线索
	if (node->lchild == NULL) {
		node->lchild = pre;
		node->ltag = 1;
	}
	// 建立前驱结点的后继线索
	if (pre != NULL && node->rchild == NULL) {
		pre->rchild = node;
		pre->rtag = 1;
	}
	pre = node;
}
int main()
{
	return 0;
}
```

##### 中序遍历

```c
#include<stdio.h>

typedef struct ThreadNode {
	int data;
	struct ThreadNode* lchild, * rchild;
	int ltag, rtag;
}ThreadNode, * ThreadTree;

void CreateInThread(ThreadTree T) {
	// 变量 pre ，指向当前访问结点的前驱
	ThreadNode* pre = NULL;
	if (T != NULL) {
		InThread(T, pre);
		// 处理遍历的最后一个结点
		// 因为采取的是左根右的顺序，最后的访问的结点一定没有右孩子，也可直接处理
		if (pre->rchild = NULL) pre->rtag = 1;
	}
}

// 中序遍历构建线索二叉树
void InThread(ThreadTree T, ThreadNode* pre) {
	if (T != NULL) {
		InThread(T->lchild, pre);
		visit(T, pre);
		InThread(T->rchild, pre);
	}
}

void visit(ThreadNode* node, ThreadNode* pre) {
	// 建立前驱线索
	if (node->lchild == NULL) {
		node->lchild = pre;
		node->ltag = 1;
	}
	// 建立前驱结点的后继线索
	if (pre != NULL && node->rchild == NULL) {
		pre->rchild = node;
		pre->rtag = 1;
	}
	pre = node;
}

// 找到以 node 为根的子树中，第一个被中序遍历的结点 即该子树的最左下角
ThreadNode* FirstNode(ThreadNode* node) {
	while (node->ltag == 0) node = node->lchild;
	return node;
}

// 找到以 node 为根的子树中，最后一个被中序遍历的结点 即该子树的最右下角
ThreadNode* LastNode(ThreadNode* node) {
	while (node->rtag == 0) node = node->rchild;
	return node;
}

// 中序线索二叉树找中序后继
// 如果rtag !=0 则 p->rchild 为后继；否则为 右 子树的最左下角
ThreadNode* NextNode(ThreadNode* node) {
	if (node->rtag == 0) return FirstNode(node->rchild);
	return node->rchild;
}

// 中序线索二叉树找中序前驱
// 如果ltag !=0 则 p->lchild 为前继；否则为 左 子树的最右下角
ThreadNode* PreNode(ThreadNode* node) {
	if (node->ltag == 0) return FirstNode(node->lchild);
	return node->rchild;
}


int main()
{
	return 0;
}
```

##### 后序遍历

```c
#include<stdio.h>

typedef struct ThreadNode {
	int data;
	struct ThreadNode* lchild, * rchild;
	int ltag, rtag;
}ThreadNode, * ThreadTree;

void CreatePostThread(ThreadTree T) {
	// 变量 pre ，指向当前访问结点的前驱
	ThreadNode* pre = NULL;
	if (T != NULL) {
		PostThread(T, pre);
		if (pre->rchild = NULL) pre->rtag = 1;
	}
}

// 后序遍历构建线索二叉树
void PostThread(ThreadTree T, ThreadNode* pre) {
	if (T != NULL) {
		PostThread(T->lchild, pre);
		PostThread(T->rchild, pre);
		visit(T, pre);
	}
}
void visit(ThreadNode* node, ThreadNode* pre) {
	// 建立前驱线索
	if (node->lchild == NULL) {
		node->lchild = pre;
		node->ltag = 1;
	}
	// 建立前驱结点的后继线索
	if (pre != NULL && node->rchild == NULL) {
		pre->rchild = node;
		pre->rtag = 1;
	}
	pre = node;
}
int main()
{
	return 0;
}
```

# 图

##### 十字链表法

```c
#include<stdio.h>
#include<malloc.h>
#define MAX_VERTEX_NUM 10

typedef struct ArcNode {
	int tailvex, headvex; // tailvex 表示弧尾顶点在图中的位置，headvex 表示弧头顶点在图中的位置
	struct ArcNode* hlink, * tlink; //hlink 指向与此弧的弧头相同的下一条弧，tlink 指向与此弧的弧尾相同的下一条弧
	// otherInfo info; // 其它信息
}ArcNode;

typedef struct VertexNode {
	char data; // 顶点数据（顶点标识，例如 A）
	ArcNode* firstin, * firstout; // firstin 指向以该顶点作为弧头的第一个弧结点，firstout 用于指向以该顶点作为弧尾的第一个弧结点
}VertexNode;

// DG 表示有向图，DN 表示有向网，UDG便是无向图，UDN表示无向网
typedef enum { DG, DN, UDG, UDN } GraphKind;

typedef struct {
	VertexNode vertex[MAX_VERTEX_NUM];
	int vexnum, arcnum; // 图的顶点数和弧数
	// GraphKind kind; //  用于记录图的种类标志
}OrthList;

// LocateVertext(OrthList * orthList,char v) 找到顶点信息 v (例如顶点标识 A) 在图中的位置
int LocateVertex(OrthList* orthList, char v) {
	for (int i = 0; i < orthList->vexnum; i++) {
		if (orthList->vertex[i].data == v) return i;
	}
	return -1;
}

void CreateOrthList(OrthList* g) {
	int vexnum, arcnum;
	printf("请输入顶点数:");
	scanf("%d", &vexnum);
	printf("请输入弧的个数:");
	scanf("%d", &arcnum);
	g->vexnum = vexnum;
	g->arcnum = arcnum;

	// 从键盘上输入各顶点
	for (int i = 0; i < vexnum; i++) {
		printf("输入结点:");
		scanf("%c", &(g->vertex[i].data));
		getchar(); // 吸收回车符
		g->vertex[i].firstin = NULL;
		g->vertex[i].firstout = NULL;
	}

	for (int i = 0; i < arcnum; i++) {
		char vh, vt;
		printf("输入弧（例如: A,B）:");
		scanf("%c,%c", &vh, &vt);
		getchar();// 吸收回车符
		int hvex = LocateVertex(g, vh);
		int tvex = LocateVertex(g, vt);
		ArcNode* p = (ArcNode*)malloc(sizeof(ArcNode));
		if (p != NULL) {
			// 记录 弧头与弧尾在数组中的索引
			p->headvex = hvex;
			p->tailvex = tvex;

			// 由于存储弧的是链表，每创建一条 弧 ，可进行头插法
			// 数组中的顶点信息，firstin 永远指向新插入的弧
			g->vertex[hvex].firstin = p;

			// 数组中的顶点信息，firstout 永远指向新插入的弧
			// 例如依次插入 A、B，A、C，则A的firstout先后等于弧AB、弧AC
			g->vertex[tvex].firstout = p;

			// 头插法之后需要将新插入的结点中的指针域进行赋值
			p->hlink = g->vertex[hvex].firstin;
			p->tlink = g->vertex[tvex].firstout;
		}
	}
}

int main()
{
	OrthList* g = (OrthList*)malloc(sizeof(OrthList));
	CreateOrthList(g);
	return 0;
}
```

##### 十字链表的广度优先遍历

```c
#include<stdio.h>
#include<malloc.h>
#define MAX_VERTEX_NUM 10

typedef struct ArcNode {
	int tailvex, headvex; // tailvex 表示弧尾顶点在图中的位置，headvex 表示弧头顶点在图中的位置
	struct ArcNode* hlink, * tlink; //hlink 指向与此弧的弧头相同的下一条弧，tlink 指向与此弧的弧尾相同的下一条弧
	// otherInfo info; // 其它信息
}ArcNode;

typedef struct VertexNode {
	char data; // 顶点数据（顶点标识，例如 A）
	ArcNode* firstin, * firstout; // firstin 指向以该顶点作为弧头的第一个弧结点，firstout 用于指向以该顶点作为弧尾的第一个弧结点
}VertexNode;

// DG 表示有向图，DN 表示有向网，UDG便是无向图，UDN表示无向网
typedef enum { DG, DN, UDG, UDN } GraphKind;

typedef struct {
	VertexNode vertex[MAX_VERTEX_NUM];
	int vexnum, arcnum; // 图的顶点数和弧数
	// GraphKind kind; //  用于记录图的种类标志
}OrthList;

typedef struct Node {
	VertexNode* data;
	struct Node* next;
}LinkQueueNode;

typedef struct {
	LinkQueueNode* front, * rear;
}LinkQueue;

bool InitQueue(LinkQueue& Q) {
	LinkQueueNode* node = (LinkQueueNode*)malloc(sizeof(LinkQueueNode));
	if (node == NULL)return false;
	Q.front = Q.rear = node;
	Q.front->next = NULL;
}

bool isEmpty(LinkQueue Q) {
	return Q.front == NULL;
}

bool EnterQueue(LinkQueue& Q, VertexNode* x) {
	LinkQueueNode* NewNode = (LinkQueueNode*)malloc(sizeof(LinkQueueNode));
	if (NewNode == NULL)return false;
	NewNode->data = x;
	NewNode->next = NULL;
	Q.rear->next = NewNode;
	Q.rear = NewNode;
}

bool DeleteQueue(LinkQueue& Q, VertexNode* x) {
	if (Q.front == Q.rear) return false;
	LinkQueueNode* FirstElem = Q.front->next;
	x = FirstElem->data;
	Q.front->next = FirstElem->next;
	if (FirstElem == Q.rear) Q.rear = Q.front;
	free(FirstElem);
	return true;
}

// LocateVertext(OrthList * orthList,char v) 找到顶点信息 v (例如顶点标识 A) 在图中的位置
int LocateVertex(OrthList* orthList, char v) {
	for (int i = 0; i < orthList->vexnum; i++) {
		if (orthList->vertex[i].data == v) return i;
	}
	return -1;
}

void CreateOrthList(OrthList* g) {
	int vexnum, arcnum;
	printf("请输入顶点数:");
	scanf("%d", &vexnum);
	printf("请输入弧的个数:");
	scanf("%d", &arcnum);
	g->vexnum = vexnum;
	g->arcnum = arcnum;

	// 从键盘上输入各顶点
	for (int i = 0; i < vexnum; i++) {
		printf("输入结点:");
		scanf("%c", &(g->vertex[i].data));
		getchar(); // 吸收回车符
		g->vertex[i].firstin = NULL;
		g->vertex[i].firstout = NULL;
	}

	for (int i = 0; i < arcnum; i++) {
		char vh, vt;
		printf("输入弧（例如: A,B）:");
		scanf("%c,%c", &vh, &vt);
		getchar();// 吸收回车符
		int hvex = LocateVertex(g, vh);
		int tvex = LocateVertex(g, vt);
		ArcNode* p = (ArcNode*)malloc(sizeof(ArcNode));
		if (p != NULL) {
			// 记录 弧头与弧尾在数组中的索引
			p->headvex = hvex;
			p->tailvex = tvex;

			// 由于存储弧的是链表，每创建一条 弧 ，可进行头插法
			// 数组中的顶点信息，firstin 永远指向新插入的弧
			g->vertex[hvex].firstin = p;

			// 数组中的顶点信息，firstout 永远指向新插入的弧
			// 例如依次插入 A、B，A、C，则A的firstout先后等于弧AB、弧AC
			g->vertex[tvex].firstout = p;

			// 头插法之后需要将新插入的结点中的指针域进行赋值
			p->hlink = g->vertex[hvex].firstin;
			p->tlink = g->vertex[tvex].firstout;
		}
	}
}
int FirstNeighbor(OrthList g, int i) {
	if (g.vertex[i].firstin != NULL) return g.vertex[i].firstin->headvex;
	return -1;
}

// i 顶点的索引
// found 已经找到的顶点的邻接点的索引，基于此找下一个邻接点
int NextNeighbor(OrthList g, int i, int found) {
	ArcNode* temp = g.vertex[i].firstin;
	for (int k = 0; k < found; k++) {
		temp = temp->tlink;
	}
	if (temp != NULL) return temp->headvex;
	return -1;
}

void visit(VertexNode n) {}

// 空间复杂度: O(|V|) 队列中加入了所有顶点
void BFSTraverse(OrthList o) {
	bool visited[MAX_VERTEX_NUM] = { false }; // 注意：此处认定图的顶点数为 MAX_VERTEX_NUM
	for (int i = 0; i < o.vexnum; i++) visited[i] = false;
	LinkQueue queue;
	InitQueue(queue);

	// 这样对非连通图也可进行遍历
	for (int i = 0; i < o.vexnum; i++) {
		if (!visited[i]) BFS(o, i, visited, &queue);
	}
}

void BFS(OrthList o, int i, bool* visited, LinkQueue* queue) {
	VertexNode* temp = (VertexNode*)malloc(sizeof(VertexNode));
	visit(o.vertex[i]);
	visited[i] = true;
	EnterQueue(*queue, &o.vertex[i]);
	while (!isEmpty(*queue)) {
		DeleteQueue(*queue, temp);
		for (int k = FirstNeighbor(o, i); k != -1; k = NextNeighbor(o, i, k)) {
			if (!visited[k]) {
				visit(o.vertex[k]);
				visited[k] = true;
				EnterQueue(*queue, &o.vertex[k]);
			}
		}
	}
}

int main()
{
	OrthList* g = (OrthList*)malloc(sizeof(OrthList));
	CreateOrthList(g);
	BFSTraverse(*g);
	return 0;
}
```

##### 十字链表的深度优先遍历

```c
#include<stdio.h>
#include<malloc.h>
#define MAX_VERTEX_NUM 10

typedef struct ArcNode {
	int tailvex, headvex; // tailvex 表示弧尾顶点在图中的位置，headvex 表示弧头顶点在图中的位置
	struct ArcNode* hlink, * tlink; //hlink 指向与此弧的弧头相同的下一条弧，tlink 指向与此弧的弧尾相同的下一条弧
	// otherInfo info; // 其它信息
}ArcNode;

typedef struct VertexNode {
	char data; // 顶点数据（顶点标识，例如 A）
	ArcNode* firstin, * firstout; // firstin 指向以该顶点作为弧头的第一个弧结点，firstout 用于指向以该顶点作为弧尾的第一个弧结点
}VertexNode;

// DG 表示有向图，DN 表示有向网，UDG便是无向图，UDN表示无向网
typedef enum { DG, DN, UDG, UDN } GraphKind;

typedef struct {
	VertexNode vertex[MAX_VERTEX_NUM];
	int vexnum, arcnum; // 图的顶点数和弧数
	// GraphKind kind; //  用于记录图的种类标志
}OrthList;

// LocateVertext(OrthList * orthList,char v) 找到顶点信息 v (例如顶点标识 A) 在图中的位置
int LocateVertex(OrthList* orthList, char v) {
	for (int i = 0; i < orthList->vexnum; i++) {
		if (orthList->vertex[i].data == v) return i;
	}
	return -1;
}

void CreateOrthList(OrthList* g) {
	int vexnum, arcnum;
	printf("请输入顶点数:");
	scanf("%d", &vexnum);
	printf("请输入弧的个数:");
	scanf("%d", &arcnum);
	g->vexnum = vexnum;
	g->arcnum = arcnum;

	// 从键盘上输入各顶点
	for (int i = 0; i < vexnum; i++) {
		printf("输入结点:");
		scanf("%c", &(g->vertex[i].data));
		getchar(); // 吸收回车符
		g->vertex[i].firstin = NULL;
		g->vertex[i].firstout = NULL;
	}

	for (int i = 0; i < arcnum; i++) {
		char vh, vt;
		printf("输入弧（例如: A,B）:");
		scanf("%c,%c", &vh, &vt);
		getchar();// 吸收回车符
		int hvex = LocateVertex(g, vh);
		int tvex = LocateVertex(g, vt);
		ArcNode* p = (ArcNode*)malloc(sizeof(ArcNode));
		if (p != NULL) {
			// 记录 弧头与弧尾在数组中的索引
			p->headvex = hvex;
			p->tailvex = tvex;

			// 由于存储弧的是链表，每创建一条 弧 ，可进行头插法
			// 数组中的顶点信息，firstin 永远指向新插入的弧
			g->vertex[hvex].firstin = p;

			// 数组中的顶点信息，firstout 永远指向新插入的弧
			// 例如依次插入 A、B，A、C，则A的firstout先后等于弧AB、弧AC
			g->vertex[tvex].firstout = p;

			// 头插法之后需要将新插入的结点中的指针域进行赋值
			p->hlink = g->vertex[hvex].firstin;
			p->tlink = g->vertex[tvex].firstout;
		}
	}
}

int FirstNeighbor(OrthList g, int i) {
	if (g.vertex[i].firstin != NULL) return g.vertex[i].firstin->headvex;
	return -1;
}

// i 顶点的索引
// found 已经找到的顶点的邻接点的索引，基于此找下一个邻接点
int NextNeighbor(OrthList g, int i, int found) {
	ArcNode* temp = g.vertex[i].firstin;
	for (int k = 0; k < found; k++) {
		temp = temp->tlink;
	}
	if (temp != NULL) return temp->headvex;
	return -1;
}
void visit(VertexNode n) {}

void DFSTraverse(OrthList o) {
	bool visited[MAX_VERTEX_NUM] = { false }; // 注意：此处认定图的顶点数为 MAX_VERTEX_NUM
	for (int i = 0; i < o.vexnum; i++) visited[i] = false;
	
	for (int i = 0; i < o.vexnum; i++) {
		if (!visited[i]) DFS(o, i, visited);
	}
}

// 深度优先遍历
void DFS(OrthList o,int i,bool *visited) {
	visit(o.vertex[i]);
	visited[i] = true;
	for (int k = FirstNeighbor(o, i); k != -1; k = NextNeighbor(o, i, k)) {
		if (!visited[k]) {
			DFS(o, k, visited);
		}
	}
}
int main()
{
	OrthList* o = (OrthList*)malloc(sizeof(OrthList));
	CreateOrthList(o);
	DFSTraverse(*o);
	return 0;
}
```

##### 无权图的单源最短路径广度优先算法

```c
void BFS_MIN_Distance(OrthList o, int u) {
	int d[MAX_VERTEX_NUM] = { 999999 }; // 记录起点到某顶点的长度
	int path[MAX_VERTEX_NUM] = { -1 }; // 记录顶点的前驱
	bool visited[MAX_VERTEX_NUM] = { false };
	d[u] = 0; // 自己到自己的距离当然是0
	visited[u] = true;
	LinkQueue queue;
	EnterQueue(queue,&o.vertex[u]);
	VertexNode* temp = (VertexNode*)malloc(sizeof(VertexNode));
	while (!isEmpty(queue)) {
		DeleteQueue(queue, temp);
		for (int k = FirstNeighbor(o, u); k != -1; k = NextNeighbor(o, u, k)) {
			if (!visited[k]) {
				d[k] = d[u] + 1;// 路径长度加一，无权图默认为一
				path[k] = u; // 记录连接前驱结点的索引
				visited[k] = true;
				EnterQueue(queue, &o.vertex[k]);
			}
		}
	}
}
```

##### Floyd算法核心代码

解决不了环路中有负权值的带权图。

```{c
for(int k=;k<n;k++){ // 考虑 v_k 作为中转点
    for(int i=0;i<n;i++){ // 遍历整个矩阵，i为行，j为列
        for(int j=0;j<n;j++){
            if(A[i][j]>A[i][k]+A[k][j]){ // A[i][j] V_i到V_j的距离
                A[i][j]=A[i][k]+A[k][j];
                path[i][j]=k; // path 矩阵代表从动v_i到v_j需不要中转点，而v_i到中转点和中转点v_j又需不需要另外的中转点也可从path矩阵中判断
            }
        }
    }
}
```

##### 邻接表的拓扑排序

```c
bool Topologicalsort(Graph G) {
    Initstack(S); //初始化栈，存储入度为0的顶点
    for (int i = 0; i < G.vexnum; i++){
		if (indegree[i] == 0){
            Push(s, i); //将所有入度为0的顶点进栈
        }
    }
    int count = 0;	//计数，记录当前已经输出的顶点数
    while (!IsEmpty(S)) { //栈不空，则存在入度为0的顶点
        Pop(s, i); //栈顶元素出栈
        print[count++] = i;//输出顶点i
        for (p = G.vertices[i].firstarc; p; p = p->nextarc) {
            //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈sv=p->adjvex;
            if (!(--indegree[v]))
                Push(S, v); // 入度为0，则入栈
        }
    }
    if (count < G.vexnum) return false; //排序失败，有向图中有回路
    else	return true; //拓扑排序成功
    
}
```

##### 逆拓扑排序的实现（DFS算法）

```c
void DFSTraverse(OrthList o) {
	bool visited[MAX_VERTEX_NUM] = { false };
	for (int i = 0; i < o.vexnum; i++) visited[i] = false;
	for (int i = 0; i < o.vexnum; i++) {
		if (!visited[i]) DFS(o, i, visited);
	}
}

void DFS(OrthList o,int i,bool *visited) {
	visited[i] = true;
	for (int k = FirstNeighbor(o, i); k != -1; k = NextNeighbor(o, i, k)) {
		if (!visited[k]) {
			DFS(o, k, visited);
		}
        // 应该加个环路判断，表示逆拓扑排序失败
	}
    // DFS 递归栈每返回一层，才会打印该顶点
    printf("%c",o.vertex[i].data);
}
```

# 查找

##### 折半查找（二分查找）

```c
int BinarySearch(int*Array,int key,int low,int high){
    int mid;
    if(low>high) return -1;
    mid=(low+high)/2;
    if(key<Array[mid])
        return BinarySearch(Array,low,mid-1,key);
    if(key>Array[mid])
        return BinarySearch(Array,low,mid+1,key);
    if(key == Array[mid])
        return mid;
}
```

## 题

#### 表达式求值

1）一位数的中缀表达式转后缀表达式

```c
#include<stdio.h>
#include<string.h>
#define MAXSIZE 80

double cal( double LeftNum, char op, double RightNum ) {
	switch (op) {
	case '+':
		return  LeftNum + RightNum;
	case '-':
		return  LeftNum - RightNum;
	case '*':
		return LeftNum * RightNum;
	case '/':
		return LeftNum / RightNum;
	}
}

int replace(char a)
{
	switch (a)
	{
	case '(':return 0;
	case '+':return 1;
	case '-':return 1;
	case '*':return 2;
	case '/':return 2;
	}
}

int compare(char s, char e)
{
	return (replace(s) < replace(e)) ? 1 : 0;
}

void InfixToPostfix(char* infix) {
	char stack[MAXSIZE];
	char postfix[MAXSIZE];
	int top = -1,count=0;// top 为 stack 的栈顶指针，count 为已经转为后缀表达式的字符数
	for (int i = 0; i < strlen(infix); i++) {
		if (infix[i] >= '0' && infix[i] <= '9') {
			postfix[count++] = infix[i];
			continue;
		}
		else {
			if (top == -1 || infix[i] == '('){
				stack[++top] = infix[i];	
				continue;
			};
			if (infix[i] == ')') {
				while (stack[top] != '(') {
					postfix[count++] = stack[top];
					top--;
				}
				top--;
				continue;
			}
			if (compare(stack[top], infix[i])) stack[++top] = infix[i];
			else {
				postfix[count++] = stack[top];
				stack[top] = infix[i];
				while (!compare(stack[top - 1], stack[top]) && top > 0)
				{
					postfix[count++] = stack[top - 1];
					stack[top - 1] = stack[top];
					top--;
				}
			}
		}
	}

	// 此时还会剩余运算符，依次出栈即可
	while (top != -1)
	{
		postfix[count++] = stack[top--];
	}
    
    // 打印结果
	for (int i = 0; i < count; i++) {
		printf("%c", postfix[i]);
	}
}

int main(void) {
	char infix[] = "(4-2)/2";
	InfixToPostfix(infix);
	return 0;
}
```

2）一位数的后缀表达式求值

```c
#include<stdio.h>
#include<string.h>
#define MAXSIZE 20

typedef struct {
	double data[MAXSIZE]; // 用静态数组存放栈元素
	int top; // 栈顶指针
}SeqStack;

void InitStack(SeqStack &S) {
	S.top = -1;
}

bool Push(SeqStack&S, double x) {
	if (S.top == MAXSIZE - 1) return false;
	S.data[++S.top] = x; // 新元素入栈
	return true;
}

bool Pop(SeqStack& S, double& x) {
	if (S.top == -1) return false;
	x = S.data[S.top--]; // 出栈后让top减一
	return true;
}

double cal( double LeftNum, char op, double RightNum ) {
	switch (op) {
	case '+':
		return  LeftNum + RightNum;
	case '-':
		return  LeftNum - RightNum;
	case '*':
		return LeftNum * RightNum;
	case '/':
		return LeftNum / RightNum;
	}
}
double ExpEvalution(char* postfix) {
	SeqStack S;
	InitStack(S);
	for (int i = 0; i < strlen(postfix); i++) {
		switch (postfix[i]) {
		case '+':
		case '-':
		case '*':
		case '/':
			double RightNum, LeftNum;
			Pop(S, RightNum);
			Pop(S, LeftNum);
			Push(S, cal(LeftNum, postfix[i],RightNum));
			break;
		case ' ':
			break;
		default:
			Push(S, postfix[i]-'0');
			break;
		}
	}
	double result;
	Pop(S, result);
	return result;
}

int main(void) {
	char postfix[] = "2 1 -";
	double result = ExpEvalution(postfix);
	printf("结果为：%f", result);
	return 0;
}
```

##### 二叉排序树

```c
typedef struct node {
	int key;
	struct node* lchild, * rchild;
}BSTNode, * BSTree;
```

 1）递归实现查找

最坏空间复杂度O(n)

```c
//在二叉排序树中查找值为key 的结点(递归实现)
//最坏空间复杂度O(h)
BSTNode *BSTSearch(BSTree T,int key){
    if (T==NULL) return NULL; //查找失败
    if ( key==T->key) return T; //查找成功
    else if (key < T->key) return BSTSearch(T->lchild. kev); //在左子树中找
}
```

 2）非递归实现查找

空间复杂度O(1)

```c
// 在二叉排序树中查找值为key 的结点
BSTNode *BSTSearch(BSTree T,int key){
    while(T!=NULL&&key !=T->key){//若树空或等于根结点值，则结束循环
        if(key<T->key) T=T->lchild; //小于，则在左子树上查找
        else T=T->rchild;   //大于，则在右子树上查找
    }
    return T;
}
```

3）插入

```c
int BSTInsert(BSTree& T, int k) {
	BSTNode* node = (BSTree)malloc(sizeof(BSTree));
	if (node!=NULL) {
		node->key = k;
		node->lchild = T->rchild = NULL;
		if (T == NULL) {
			T = node;
			return 1;
		}
		BSTNode* temp = T;
		while (temp != NULL) {
			if (k < temp->key) {
				if (temp->lchild == NULL) temp->lchild = node;
				temp = temp->lchild;
			}
			else {
				if (temp->rchild == NULL) temp->rchild = node;
				temp = temp->rchild;
			}
		}
		return 1;
	}
	return -1;
}
```

# 排序

##### 插入排序

```c
#include<stdio.h>
# define MAXSIZE 100

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}
// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引，从0开始
// int e 表示插入的元素
bool ListInsert(SeqList& L, int i, int e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false;

	for (int j = L.length - 1; j >= i; j--)  L.data[j + 1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}

// 插入排序针对的是前两个元素已排好序的数组 list，对剩余元素进行排序
// 这里默认前两个元素从小到大
void InsertSort(SeqList& list) {
	int temp;
	for (int i = 1; i < list.length; i++) {
		if (list.data[i - 1] > list.data[i]) {
			temp = list.data[i]; // 当左边数比右边的数大时，记录右边较小的数
			int j = i - 1;
			while (j >= 0&&list.data[j]>temp) {
				// 将左边的元素右移
				list.data[j + 1] = list.data[j];
				j--;
			}
			list.data[j + 1] = temp;
		}
	}
}

int main()
{
	SeqList list;
	InitList(list);
	ListInsert(list, 0, 2);
	ListInsert(list, 1, 3);
	ListInsert(list, 2, 5);
	ListInsert(list, 3, 1);
	ListInsert(list, 4, 4);
	InsertSort(list);
	for (int i = 0; i < list.length; i++) {
		printf("%d ", list.data[i]);
	}
	return 0;
}
```

##### 希尔排序

```c
#include<stdio.h>
# define MAXSIZE 100

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}
// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引，从0开始
// int e 表示插入的元素
bool ListInsert(SeqList& L, int i, int e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false;

	for (int j = L.length - 1; j >= i; j--)  L.data[j + 1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}

// 默认从小到大
void ShellSort(SeqList& list, int delta) {
	int temp;
	for (int d = delta; d >= 1; d = d / 2) {
		// 如果 list.data[0]做哨兵，则 i = d+1;i <= list.length;while 中 j > 0
		for (int i = d; i < list.length; i++) {
			// 先中间偏右的元素与 索引为 i-d 元素先比较
			if (list.data[i - d] > list.data[i]) {
				temp = list.data[i];
				// 将左边元素右移
				int j = i - d;
				while (j >= 0 && list.data[j] > temp) {
					list.data[j + d] = list.data[j];
					j -= d;
				}
				list.data[j + d] = temp;
			}
		}
	}
}


int main()
{
	SeqList list;
	InitList(list);
	ListInsert(list, 0, 2);
	ListInsert(list, 1, 3);
	ListInsert(list, 2, 5);
	ListInsert(list, 3, 1);
	ListInsert(list, 4, 4);
	ShellSort(list, 1);
	for (int i = 0; i < list.length; i++) {
		printf("%d ", list.data[i]);
	}
	return 0;
}
```

### 交换排序

##### 冒泡排序

```c
// 默认从小到大
void BubbleSort(SeqList& list) {
	int temp;
	bool isChange = false;
	for(int i=0;i<list.length;i++){
		for (int j = list.length-1; j > i; j--) {
			if (list.data[j - 1] > list.data[j]) {
				temp = list.data[j];
				list.data[j] = list.data[j - 1];
				list.data[j - 1] = temp;
				isChange = true;
			}
		}
        // 如果在某一趟冒泡排序时没有发现一个逆序，则直接结束整个冒泡排序过程
		if (!isChange) return;
		else isChange = false;
	}
}
```

##### 快速排序

```c
#include<stdio.h>
# define MAXSIZE 100

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}
// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引，从0开始
// int e 表示插入的元素
bool ListInsert(SeqList& L, int i, int e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false;

	for (int j = L.length - 1; j >= i; j--)  L.data[j + 1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}

// 默认从小到大
int Partition(SeqList& list,int low,int high) {
	// 暂存 枢轴 pivot，此时可看成  list.data[low] 为空
	int pivot= list.data[low];
	while (low < high) {
		// 找到一个比枢轴 pivot 小的数对应的索引
		while (low < high && list.data[high] >= pivot) high--;

		// 将该比 pivot 小的数填入 list.data[low]，此时又看将list.data[high] 看成空
		list.data[low] = list.data[high];

		// 从左到右找到一个比枢轴 pivot 大的数对应的索引
		while (low < high && list.data[low] <= pivot) low++;

		// 将该比 pivot 大的数填入 list.data[high]，此时又看将list.data[low] 看成空
		list.data[high] = list.data[low];
	}
	// 跳出 while 循环后，low == high，且 list.data[low/high] 可看成空，需要填入 pivot
	list.data[low] = pivot;
	return low;
}

void QuickSort(SeqList& list, int low, int high) {
	if (low < high) {
		int pivotpos = Partition(list, low, high);
		QuickSort(list, low, pivotpos - 1); // 划分左子表
		QuickSort(list, pivotpos + 1,high); // 划分右子表

	}
}

int main()
{
	SeqList list;
	InitList(list);
	ListInsert(list, 0, 2);
	ListInsert(list, 1, 3);
	ListInsert(list, 2, 5);
	ListInsert(list, 3, 1);
	ListInsert(list, 4, 4);
	QuickSort(list,0,list.length-1);
	for (int i = 0; i < list.length; i++) {
		printf("%d ", list.data[i]);
	}
	return 0;
}

```

### 选择排序

##### 简单选择排序

```c
void SelectSort(SeqList& list) {
	// 最后一个元素不用排序，排剩下的最后一个已成最大的元素
	for (int i = 0; i < list.length - 1; i++) {
		int min = i;
		for (int j = i + 1; j < list.length; j++) {
			if (list.data[j] < list.data[min]) min = j;
		}
		// 找了一圈，如果发现了最小的不是索引为 i 的则替换
		if (min != i) {
			int temp = list.data[i];
			list.data[i] = list.data[min];
			list.data[min] = temp;
		}
	}
}
```

##### 堆排序

大顶推：

```c
#include<stdio.h>
# define MAXSIZE 100

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}
// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引，从0开始
// int e 表示插入的元素
bool ListInsert(SeqList& L, int i, int e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false;

	for (int j = L.length - 1; j >= i; j--)  L.data[j + 1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}

// int length 不是指 list 数组的长度，而是指需要数组中前 length 个元素需要处理
void HeadAdjust(SeqList& list, int k,int length) {
	int temp = list.data[k];
	// 因为数组索引从0算起，所以i=2*k+1 为分支结点的左孩子，如果从1算起，则i=2*k为左孩子
	for (int i = 2 * k+ 1; i < length; i = 2*i+1) {
		// 如果右孩子的值更大，则指向有孩子
		if (i < list.length - 1 && list.data[i] < list.data[i + 1]) i+=1;
		// 如果分支结点比孩子中更大的还要大，则此次筛选结束
		if (temp >= list.data[i]) break;
		else {
			// 如果分支结点较小，则与更大的孩子交换，由于交换后可能会造成子树变化，还需要继续筛选
			list.data[k] = list.data[i];
			// 此时的 list.data[i] 可看成空，temp 元素还需要在子树中进行比较与交换
			k = i;
		}
	}
	// 最终的 list.data[k] 填入 temp
	list.data[k] = temp;
}

// 构建大顶堆
void BuildMaxHeap(SeqList& list) {
	// 一定是从最后一个分支结点开始筛选
    // 如果元素从下标1开始存，则 int i = list.length / 2; i > 0
	for (int i = (list.length-1) / 2; i >= 0; i--) {
	HeadAdjust(list, i,list.length);
	}
}

void HeapSort(SeqList& list) {
	BuildMaxHeap(list);
	// 需要交换到还剩1个元素为止
	for(int i=list.length-1;i>1;i--){
		int temp = list.data[i];
		list.data[i] = list.data[0];
		list.data[0] = temp;
		HeadAdjust(list, 0, i-1);
	}
}

int main()
{
	SeqList list;
	InitList(list);
	ListInsert(list, 0, 53);
	ListInsert(list, 1, 17);
	ListInsert(list, 2, 78);
	ListInsert(list, 3, 9);
	ListInsert(list, 4, 45);
	ListInsert(list, 5, 65);
	ListInsert(list, 6, 87);
	ListInsert(list, 7, 32);
	HeapSort(list);
	for (int i = 0; i < list.length; i++) {
		printf("%d ", list.data[i]);
	}
	return 0;
}
```

###  归并排序

```c
#include<stdio.h>
#include<malloc.h>
# define MAXSIZE 100

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

void InitList(SeqList& L) {
	for (int i = 0; i < MAXSIZE; i++) L.data[i] = 0;
	L.length = 0;
}
// SeqList &L 表示待插入元素的数组
// int i 表示插入元素在数组中的索引，从0开始
// int e 表示插入的元素
bool ListInsert(SeqList& L, int i, int e) {
	// 当存在元素时，最后一个元素的索引为 L.length-1， 允许插入的范围为 0 至 L.length
	if (i<0 || i> L.length) return false;

	// 当数组长度已达最大时，拒绝插入
	if (L.length >= MAXSIZE) return false;

	for (int j = L.length - 1; j >= i; j--)  L.data[j + 1] = L.data[j];

	L.data[i] = e;
	L.length++;
	return true;
}

void Merge(SeqList &list, int low, int mid, int high) {
	int* b = (int*)malloc((high-low+1) * sizeof(int));
	int i, j, k;
	for(i=low;i<=high;i++){
		b[i] =list.data[i];
	}

	for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) {
		if (b[i] <= b[j]) list.data[k] = b[i++];
		else list.data[k] = b[j++];
	}
	while (i <= mid) list.data[k++] = b[i++];
	while (j <= high) list.data[k++] = b[j++];
}

void MergeSort(SeqList& list, int low, int high) {
	if (low < high) {
		int mid = (low + high) / 2;
		MergeSort(list, low, mid);
		MergeSort(list, mid+1, high);
		Merge(list, low, mid, high);
	}
}
int main()
{
	SeqList list;
	InitList(list);
	ListInsert(list, 0, 53);
	ListInsert(list, 1, 17);
	ListInsert(list, 2, 78);
	ListInsert(list, 3, 9);
	ListInsert(list, 4, 45);
	ListInsert(list, 5, 65);
	ListInsert(list, 6, 87);
	ListInsert(list, 7, 32);
	MergeSort(list, 0, list.length-1);
	for (int i = 0; i < list.length; i++) {
		printf("%d ", list.data[i]);
	}
	return 0;
}
```

#### 斐波那契数列

1，1，2，3，5，8，13，21...

1）递归实现

```c
#include<stdio.h>
#include<stdlib.h>
long long Fib(long long N)
{
	if (N < 3) //当N<3时，斐波那契数为1
		return 1;
	return Fib(N - 1) + Fib(N - 2);//函数递归
}
int main()
{
	int n = 5;
	printf("%d", Fib(n)); // 计算第5个斐波那契数
	return 0;
}
```

时间复杂度：O(2<sup>n</sup>)

2）非递归实现

```c
#include<stdio.h>
#include<stdlib.h>
long Fib(long n)
{
	// 如果输入的是0，返回的结果为0
	if (n ==0 || n==1) return n;
	int x = 0,y = 1,z;
	for (int i = 2; i <= n; i++) {
		z = x + y;
		x = y;
		y = z;
	}
	return z;
}
int main()
{
	int n = 6;
	printf("%d", Fib(n));
	return 0;
}
```

时间复杂度：O(n)