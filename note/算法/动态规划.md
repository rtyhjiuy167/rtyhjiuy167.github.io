###  爬楼梯

leetcode：https://leetcode.cn/problems/climbing-stairs/

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

```
状态转移方程：dp[i]=dp[i−1]+dp[i−2]
```

```ts
// 空间 O(n)
// 时间 O(n) 
function climbStairs(n: number) {
  const dp = [0, 1, 2]
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 2] + dp[i - 1]
  }
  return dp[n]
}
```

因为实际上只用到f(x)，f(x−1)，f(x−2)三种状态，可以对空间进行优化：

```ts
// 对空间优化 O(n) -> O(1)
function climbStairs(n: number) {
  if (n === 1) return 1
  if (n === 2) return 2
  let first = 1,
    second = 2
  for (let i = 3; i <= n; i++) {
    let third = first + second
    first = second
    second = third
  }
  return second
}
```

### 打家劫舍

leetcode：https://leetcode.cn/problems/house-robber/

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

```
偷窃第 i 间房屋，那么就不能偷窃第 i−1 间房屋，偷窃总金额为前 i−2 间房屋的最高总金额与第 i 间房屋的金额之和
不偷窃第 i 间房屋，偷窃总金额为前 i−1 间房屋的最高总金额
状态转移方程：dp[i]=max(dp[i−2]+nums[i],dp[i−1])
```

```ts
// 空间 O(n)
// 时间 O(n) 
function rob(nums: number[]) {
  if (nums.length === 0) return 0
  if (nums.length === 1) return nums[0]
  const dp = [nums[0], Math.max(nums[0], nums[1])]
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
  }
  return dp[nums.length - 1]
}
```

考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。

```ts
// 对空间优化 O(n) -> O(1)
function rob(nums: number[]) {
  if (nums.length === 0) return 0
  if (nums.length === 1) return nums[0]
  let first = nums[0]
  let second = Math.max(nums[0], nums[1])
  for (let i = 2; i < nums.length; i++) {
    let third = Math.max(first + nums[i], second)
    first = second
    second = third
  }
  return second
}
```

